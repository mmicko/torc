<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Verilator - Convert Verilog code to C++/SystemC</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:feedback@suse.de" />
</head>

<body style="background-color: white">


<!-- INDEX BEGIN -->
<div name="index">
<p><a name="__index__"></a></p>

<ul>

	<li><a href="#name">NAME</a></li>
	<li><a href="#synopsis">SYNOPSIS</a></li>
	<li><a href="#description">DESCRIPTION</a></li>
	<li><a href="#argument_summary">ARGUMENT SUMMARY</a></li>
	<li><a href="#arguments">ARGUMENTS</a></li>
	<li><a href="#example_c___execution">EXAMPLE C++ EXECUTION</a></li>
	<li><a href="#example_systemc_execution">EXAMPLE SYSTEMC EXECUTION</a></li>
	<li><a href="#benchmarking___optimization">BENCHMARKING &amp; OPTIMIZATION</a></li>
	<li><a href="#files">FILES</a></li>
	<li><a href="#environment">ENVIRONMENT</a></li>
	<li><a href="#connecting_to_c__">CONNECTING TO C++</a></li>
	<li><a href="#connecting_to_systemc">CONNECTING TO SYSTEMC</a></li>
	<li><a href="#direct_programming_interface__dpi_">DIRECT PROGRAMMING INTERFACE (DPI)</a></li>
	<ul>

		<li><a href="#dpi_example">DPI Example</a></li>
		<li><a href="#dpi_system_task_functions">DPI System Task/Functions</a></li>
		<li><a href="#dpi_display_functions">DPI Display Functions</a></li>
		<li><a href="#dpi_context_functions">DPI Context Functions</a></li>
		<li><a href="#dpi_header_isolation">DPI Header Isolation</a></li>
		<li><a href="#public_functions">Public Functions</a></li>
	</ul>

	<li><a href="#verification_procedural_interface__vpi_">VERIFICATION PROCEDURAL INTERFACE (VPI)</a></li>
	<ul>

		<li><a href="#vpi_example">VPI Example</a></li>
	</ul>

	<li><a href="#cross_compilation">CROSS COMPILATION</a></li>
	<ul>

		<li><a href="#cadence_nc_systemc_models">Cadence NC-SystemC Models</a></li>
	</ul>

	<li><a href="#configuration_files">CONFIGURATION FILES</a></li>
	<li><a href="#language_standard_support">LANGUAGE STANDARD SUPPORT</a></li>
	<ul>

		<li><a href="#verilog_2001__ieee_1364_2001__support">Verilog 2001 (IEEE 1364-2001) Support</a></li>
		<li><a href="#verilog_2005__ieee_1364_2005__support">Verilog 2005 (IEEE 1364-2005) Support</a></li>
		<li><a href="#systemverilog_2005__ieee_1800_2005__support">SystemVerilog 2005 (IEEE 1800-2005) Support</a></li>
		<li><a href="#systemverilog_2009__ieee_1800_2009__support">SystemVerilog 2009 (IEEE 1800-2009) Support</a></li>
		<li><a href="#verilog_ams_support">Verilog AMS Support</a></li>
		<li><a href="#sugar_psl_support">Sugar/PSL Support</a></li>
		<li><a href="#synthesis_directive_assertion_support">Synthesis Directive Assertion Support</a></li>
	</ul>

	<li><a href="#language_extensions">LANGUAGE EXTENSIONS</a></li>
	<li><a href="#language_limitations">LANGUAGE LIMITATIONS</a></li>
	<ul>

		<li><a href="#synthesis_subset">Synthesis Subset</a></li>
		<li><a href="#dotted_cross_hierarchy_references">Dotted cross-hierarchy references</a></li>
		<li><a href="#floating_point">Floating Point</a></li>
		<li><a href="#latches">Latches</a></li>
		<li><a href="#time">Time</a></li>
		<li><a href="#two_state">Two State</a></li>
		<li><a href="#tri_inout">Tri/Inout</a></li>
		<li><a href="#functions___tasks">Functions &amp; Tasks</a></li>
		<li><a href="#generated_clocks">Generated Clocks</a></li>
		<li><a href="#ranges_must_be_big_bit_endian">Ranges must be big-bit-endian</a></li>
		<li><a href="#gate_primitives">Gate Primitives</a></li>
		<li><a href="#specify_blocks">Specify blocks</a></li>
		<li><a href="#array_initialization">Array Initialization</a></li>
		<li><a href="#array_out_of_bounds">Array Out of Bounds</a></li>
		<li><a href="#assertions">Assertions</a></li>
		<li><a href="#language_keyword_limitations">Language Keyword Limitations</a></li>
	</ul>

	<li><a href="#errors_and_warnings">ERRORS AND WARNINGS</a></li>
	<li><a href="#faq_frequently_asked_questions">FAQ/FREQUENTLY ASKED QUESTIONS</a></li>
	<li><a href="#bugs">BUGS</a></li>
	<li><a href="#history">HISTORY</a></li>
	<li><a href="#contributors">CONTRIBUTORS</a></li>
	<li><a href="#distribution">DISTRIBUTION</a></li>
	<li><a href="#authors">AUTHORS</a></li>
	<li><a href="#see_also">SEE ALSO</a></li>
</ul>

<hr name="index" />
</div>
<!-- INDEX END -->

<p>
</p>
<hr />
<h1><a name="name">NAME</a></h1>
<p>Verilator - Convert Verilog code to C++/SystemC</p>
<p>
</p>
<hr />
<h1><a name="synopsis">SYNOPSIS</a></h1>
<pre>
    verilator --help
    verilator --version
    verilator --cc [options] [top_level.v] [opt_c_files.cpp/c/cc/a/o/so]
    verilator --sc [options] [top_level.v] [opt_c_files.cpp/c/cc/a/o/so]
    verilator --sp [options] [top_level.v] [opt_c_files.cpp/c/cc/a/o/so]
    verilator --lint-only    [top_level.v]...</pre>
<p>
</p>
<hr />
<h1><a name="description">DESCRIPTION</a></h1>
<p>Verilator converts synthesizable (not behavioral) Verilog code, plus some
Synthesis, SystemVerilog and a small subset of Verilog AMS and Sugar/PSL
assertions, into C++, SystemC or SystemPerl code.  It is not a complete
simulator, just a compiler.</p>
<p>Verilator is invoked with parameters similar to GCC, Cadence
Verilog-XL/NC-Verilog, or Synopsys's VCS.  It reads the specified Verilog
code, lints it, and optionally adds coverage and waveform tracing code.
For C++ and SystemC formats, it outputs .cpp and .h files.  For SystemPerl
format, it outputs .sp files for the SystemPerl preprocessor, which greatly
simplifies writing SystemC code and is available at
<a href="http://www.veripool.org">http://www.veripool.org</a>.</p>
<p>The files created by Verilator are then compiled with C++.  The user writes
a little C++ wrapper file, which instantiates the top level module, and
passes this filename on the command line.  These C files are compiled in
C++, and linked with the Verilated files.</p>
<p>The resulting executable will perform the actual simulation.</p>
<p>To get started, jump down to &quot;EXAMPLE C++ EXECUTION&quot;.</p>
<p>
</p>
<hr />
<h1><a name="argument_summary">ARGUMENT SUMMARY</a></h1>
<p>This is a short summary of the arguments to Verilator.  See the detailed
descriptions in the next sections for more information.</p>
<pre>
    {file.v}                    Verilog top level filenames
    {file.c/cc/cpp}             Optional C++ files to compile in
    {file.a/o/so}               Optional C++ files to link in</pre>
<pre>
    --assert                    Enable all assertions
    --autoflush                 Flush streams after all $displays
    --bbox-sys                  Blackbox unknown $system calls
    --bbox-unsup                Blackbox unsupported language features
    --bin &lt;filename&gt;            Override Verilator binary
     -CFLAGS &lt;flags&gt;            C++ Compiler flags for makefile
    --cc                        Create C++ output
    --cdc                       Clock domain crossing analysis
    --compiler &lt;compiler-name&gt;  Tune for specified C++ compiler
    --coverage                  Enable all coverage
    --coverage-line             Enable line coverage
    --coverage-toggle           Enable toggle coverage
    --coverage-user             Enable PSL/SVL user coverage
    --coverage-underscore       Enable covarge of _signals
     -D&lt;var&gt;[=&lt;value&gt;]          Set preprocessor define
    --debug                     Enable debugging
    --debug-check               Enable debugging assertions
    --debugi &lt;level&gt;            Enable debugging at a specified level
    --debugi-&lt;srcfile&gt; &lt;level&gt;  Enable debugging a source file at a level
     +define+&lt;var&gt;+&lt;value&gt;      Set preprocessor define
    --dump-tree                 Enable dumping .tree files
     -E                         Preprocess, but do not compile
    --error-limit &lt;value&gt;       Abort after this number of errors
    --exe                       Link to create executable
     -F &lt;file&gt;                  Parse options from a file, relatively
     -f &lt;file&gt;                  Parse options from a file
    --gdbbt                     Run Verilator under GDB for backtrace
    --help                      Display this help
     -I&lt;dir&gt;                    Directory to search for includes
    --if-depth &lt;value&gt;          Tune IFDEPTH warning
     +incdir+&lt;dir&gt;              Directory to search for includes
    --inhibit-sim               Create function to turn off sim
    --inline-mult &lt;value&gt;       Tune module inlining
     -LDFLAGS &lt;flags&gt;           Linker pre-object flags for makefile
     -LDLIBS &lt;flags&gt;            Linker library flags for makefile
    --language &lt;lang&gt;           Language standard to parse
     +libext+&lt;ext&gt;+[ext]...     Extensions for finding modules
    --lint-only                 Lint, but do not make output
    --MMD                       Create .d dependency files
    --MP                        Create phony dependency targets
    --Mdir &lt;directory&gt;          Name of output object directory
    --mod-prefix &lt;topname&gt;      Name to prepend to lower classes
    --no-pins64                 Don't use vluint64_t's for 33-64 bit sigs
    --no-skip-identical         Disable skipping identical output
     +notimingchecks            Ignored
     -O0                        Disable optimizations
     -O3                        High performance optimizations
     -O&lt;optimization-letter&gt;    Selectable optimizations
     -o &lt;executable&gt;            Name of final executable
    --output-split &lt;bytes&gt;      Split .cpp files into pieces
    --output-split-cfuncs &lt;statements&gt;   Split .ccp functions
    --pins-bv &lt;bits&gt;            Specify types for top level ports
    --pins-uint8                Specify types for top level ports
    --pipe-filter &lt;command&gt;     Filter all input through a script
    --prefix &lt;topname&gt;          Name of top level class
    --profile-cfuncs            Name functions for profiling
    --private                   Debugging; see docs
    --psl                       Enable PSL parsing
    --public                    Debugging; see docs
    --sc                        Create SystemC output
    --sp                        Create SystemPerl output
    --stats                     Create statistics file
     -sv                        Enable SystemVerilog parsing
    --top-module &lt;topname&gt;      Name of top level input module
    --trace                     Enable waveform creation
    --trace-depth &lt;levels&gt;      Depth of tracing
    --trace-max-array &lt;depth&gt;   Maximum bit width for tracing
    --trace-max-width &lt;width&gt;   Maximum array depth for tracing
    --trace-underscore          Enable tracing of _signals
     -U&lt;var&gt;                    Undefine preprocessor define
    --unroll-count &lt;loops&gt;      Tune maximum loop iterations
    --unroll-stmts &lt;stmts&gt;      Tune maximum loop body size
    --unused-regexp &lt;regexp&gt;    Tune UNUSED lint signals
     -V                         Verbose version and config
     -v &lt;filename&gt;              Verilog library
     -Werror-&lt;message&gt;          Convert warning to error
     -Wfuture-&lt;message&gt;         Disable unknown message warnings
     -Wno-&lt;message&gt;             Disable warning
     -Wno-lint                  Disable all lint warnings
     -Wno-style                 Disable all style warnings
     -Wno-fatal                 Disable fatal exit on warnings
     -x-assign &lt;mode&gt;           Initially assign Xs to this value
     -y &lt;dir&gt;                   Directory to search for modules</pre>
<p>
</p>
<hr />
<h1><a name="arguments">ARGUMENTS</a></h1>
<dl>
<dt><strong><a name="file_v" class="item">{file.v}</a></strong>

<dd>
<p>Specifies the Verilog file containing the top module to be Verilated.</p>
</dd>
</li>
<dt><strong><a name="file_c_cc_cpp_cxx" class="item">{file.c/.cc/.cpp/.cxx}</a></strong>

<dd>
<p>Specifies optional C++ files to be linked in with the Verilog code.  If any
C++ files are specified in this way, Verilator will include a make rule
that generates a <em>module</em> executable.  Without any C++ files, Verilator
will stop at the <em>module</em>__ALL.a library, and presume you'll continue
linking with make rules you write yourself.  See also the -CFLAGS option.</p>
</dd>
</li>
<dt><strong><a name="file_a_o_so" class="item">{file.a/.o/.so}</a></strong>

<dd>
<p>Specifies optional object or library files to be linked in with the Verilog
code, as a shorthand for -LDFLAGS &quot;&lt;file&gt;&quot;.  If any files are specified in
this way, Verilator will include a make rule that uses these files when
linking the <em>module</em> executable.  This generally is only useful when used
with the --exe option.</p>
</dd>
</li>
<dt><strong><a name="assert" class="item">--assert</a></strong>

<dd>
<p>Enable all assertions, includes enabling the --psl flag.  (If psl is not
desired, but other assertions are, use --assert --nopsl.)</p>
</dd>
<dd>
<p>See also --x-assign; setting &quot;--x-assign unique&quot; may be desirable.</p>
</dd>
</li>
<dt><strong><a name="autoflush" class="item">--autoflush</a></strong>

<dd>
<p>After every $display or $fdisplay, flush the output stream.  This insures
that messages will appear immediately but may reduce performance.  Defaults
off, which will buffer output as provided by the normal C stdio calls.</p>
</dd>
</li>
<dt><strong><a name="bbox_sys" class="item">--bbox-sys</a></strong>

<dd>
<p>Black box any unknown $system task or function calls.  System tasks will be
simply NOPed, and system functions will be replaced by unsized zero.
Arguments to such functions will be parsed, but not otherwise checked.
This prevents errors when linting in the presence of company specific PLI
calls.</p>
</dd>
</li>
<dt><strong><a name="bbox_unsup" class="item">--bbox-unsup</a></strong>

<dd>
<p>Black box some unsupported language features, currently UDP tables and the
cmos and tran gate primitives.  This may enable linting the rest of the
design even when unsupported constructs are present.</p>
</dd>
</li>
<dt><strong><a name="bin_filename" class="item">--bin <em>filename</em></a></strong>

<dd>
<p>Rarely needed.  Override the default filename for Verilator itself.  When a
dependency (.d) file is created, this filename will become a source
dependency, such that a change in this binary will have make rebuild the
output files.</p>
</dd>
</li>
<dt><strong><a name="cflags_flags" class="item">-CFLAGS <em>flags</em></a></strong>

<dd>
<p>Add specified C compiler flags to the generated makefiles.  When make is
run on the generated makefile these will be passed to the C++ compiler
(gcc/g++/msvc++).</p>
</dd>
</li>
<dt><strong><a name="cc" class="item">--cc</a></strong>

<dd>
<p>Specifies C++ without SystemC output mode; see also --sc and --sp.</p>
</dd>
</li>
<dt><strong><a name="cdc" class="item">--cdc</a></strong>

<dd>
<p>Experimental.  Perform some clock domain crossing checks and issue related
warnings (CDCRSTLOGIC) and then exit; if warnings other than CDC warnings
are needed make a second run with --lint-only.  Additional warning
information is also written to the file {prefix}__cdc.txt.</p>
</dd>
<dd>
<p>Currently only checks some items that other CDC tools missed; if you have
interest in adding more traditional CDC checks, please contact the authors.</p>
</dd>
</li>
<dt><strong><a name="compiler_compiler_name" class="item">--compiler <em>compiler-name</em></a></strong>

<dd>
<p>Enables tunings and work-arounds for the specified C++ compiler.</p>
</dd>
<dl>
<dt><strong><a name="gcc" class="item">gcc</a></strong>

<dd>
<p>Tune for Gnu C++, although generated code should work on almost any
compliant C++ compiler.  Currently the default.</p>
</dd>
</li>
<dt><strong><a name="msvc" class="item">msvc</a></strong>

<dd>
<p>Tune for Microsoft Visual C++.  This may reduce execution speed as it
enables several workarounds to avoid silly hardcoded limits in MSVC++.
This includes breaking deeply nested parenthesized expressions into
sub-expressions to avoid error C1009, and breaking deep blocks into
functions to avoid error C1061.</p>
</dd>
</li>
</dl>
<dt><strong><a name="coverage" class="item">--coverage</a></strong>

<dd>
<p>Enables all forms of coverage, alias for &quot;--coverage-line --coverage-toggle
--coverage-user&quot;.</p>
</dd>
</li>
<dt><strong><a name="coverage_line" class="item">--coverage-line</a></strong>

<dd>
<p>Specifies basic block line coverage analysis code should be inserted.</p>
</dd>
<dd>
<p>Coverage analysis adds statements at each code flow change point, which are
the branches of IF and CASE statements, a super-set of normal Verilog Line
Coverage.  At each such branch a unique counter is incremented.  At the end
of a test, the counters along with the filename and line number
corresponding to each counter are written into logs/coverage.pl.</p>
</dd>
<dd>
<p>Verilator automatically disables coverage of branches that have a $stop in
them, as it is assumed $stop branches contain an error check that should
not occur.  A /*verilator coverage_block_off*/ comment will perform a
similar function on any code in that block or below, or /*verilator
coverage_on/coverage_off*/ will disable coverage around lines of code.</p>
</dd>
<dd>
<p>Note Verilator may over-count combinatorial (non-clocked) blocks when those
blocks receive signals which have had the UNOPTFLAT warning disabled; for
most accurate results do not disable this warning when using coverage.</p>
</dd>
</li>
<dt><strong><a name="coverage_toggle" class="item">--coverage-toggle</a></strong>

<dd>
<p>Specifies signal toggle coverage analysis code should be inserted.</p>
</dd>
<dd>
<p>Every bit of every signal in a module has a counter inserted.  The counter
will increment on every edge change of the corresponding bit.</p>
</dd>
<dd>
<p>Signals that are part of tasks or begin/end blocks are considered local
variables and are not covered.  Signals that begin with underscores, are
integers, or are very wide (&gt;256 bits total storage across all dimensions)
are also not covered.</p>
</dd>
<dd>
<p>Hierarchy is compressed, such that if a module is instantiated multiple
times, coverage will be summed for that bit across ALL instantiations of
that module with the same parameter set.  A module instantiated with
different parameter values is considered a different module, and will get
counted separately.</p>
</dd>
<dd>
<p>Verilator makes a minimally-intelligent decision about what clock domain
the signal goes to, and only looks for edges in that clock domain.  This
means that edges may be ignored if it is known that the edge could never be
seen by the receiving logic.  This algorithm may improve in the future.
The net result is coverage may be lower than what would be seen by looking
at traces, but the coverage is a more accurate representation of the
quality of stimulus into the design.</p>
</dd>
<dd>
<p>There may be edges counted near time zero while the model stabilizes.  It's
a good practice to zero all coverage just before releasing reset to prevent
counting such behavior.</p>
</dd>
<dd>
<p>A /*verilator coverage_off/on */ comment pair can be used around signals
that do not need toggle analysis, such as RAMs and register files.</p>
</dd>
</li>
<dt><strong><a name="coverage_underscore" class="item">--coverage-underscore</a></strong>

<dd>
<p>Enable coverage of signals that start with an underscore. Normally, these
signals are not covered.  See also --trace-underscore.</p>
</dd>
</li>
<dt><strong><a name="coverage_user" class="item">--coverage-user</a></strong>

<dd>
<p>Enables user inserted functional coverage.  Currently, all functional
coverage points are specified using PSL which must be separately enabled
with --psl.</p>
</dd>
<dd>
<p>For example, the following PSL statement will add a coverage point, with
the comment &quot;DefaultClock&quot;:</p>
</dd>
<dd>
<pre>
   // psl default clock = posedge clk;
   // psl cover {cyc==9} report &quot;DefaultClock,expect=1&quot;;</pre>
</dd>
</li>
<dt><strong><a name="dvar_value" class="item">-D<em>var</em>=<em>value</em></a></strong>

<dd>
<p>Defines the given preprocessor symbol.  Same as +define; +define is fairly
standard across Verilog tools while -D is an alias for GCC compatibility.</p>
</dd>
</li>
<dt><strong><a name="debug" class="item">--debug</a></strong>

<dd>
<p>Select the debug built image of Verilator (if available), and enable more
internal assertions, debugging messages, and intermediate form dump files.</p>
</dd>
</li>
<dt><strong><a name="debug_check" class="item">--debug-check</a></strong>

<dd>
<p>Rarely needed.  Enable internal debugging assertion checks, without
changing debug verbosity.  Enabled automatically when --debug specified.</p>
</dd>
</li>
<dt><strong><a name="debugi_level_item_debugi_srcfile_level" class="item">--debugi &lt;level&gt;
=item --debugi-&lt;srcfile&gt; &lt;level&gt;</a></strong>

<dd>
<p>Rarely needed - for developer use.  Set internal debugging level globally
or on the specified source file to the specified level.</p>
</dd>
</li>
<dt><strong><a name="define_var_value" class="item">+define+<em>var</em>+<em>value</em></a></strong>

<dd>
<p>Defines the given preprocessor symbol.  Same as -D; +define is fairly
standard across Verilog tools while -D is an alias for GCC compatibility.</p>
</dd>
</li>
<dt><strong><a name="dump_tree" class="item">--dump-tree</a></strong>

<dd>
<p>Rarely needed.  Enable writing .tree debug files.  This is enabled with
--debug, so &quot;--debug --no-dump-tree&quot; may be useful if the dump files are
large and not desired.</p>
</dd>
</li>
<dt><strong><a name="e" class="item">-E</a></strong>

<dd>
<p>Preprocess the source code, but do not compile, as with 'gcc -E'.  Output
is written to standard out.  Beware of enabling debugging messages, as they
will also go to standard out.</p>
</dd>
</li>
<dt><strong><a name="error_limit_value" class="item">--error-limit &lt;value&gt;</a></strong>

<dd>
<p>After this number of errors or warnings are encountered, exit.  Defaults to
50.</p>
</dd>
</li>
<dt><strong><a name="exe" class="item">--exe</a></strong>

<dd>
<p>Generate an executable.  You will also need to pass additional .cpp files on
the command line that implement the main loop for your simulation.</p>
</dd>
</li>
<dt><strong><a name="f_file" class="item">-F <em>file</em></a></strong>

<dd>
<p>Read the specified file, and act as if all text inside it was specified as
command line parameters.  Any relative paths are relative to the directory
containing the specified file.  See also -f. Note -F is fairly standard
across Verilog tools.</p>
</dd>
</li>
<dt><strong><a name="f_file" class="item">-f <em>file</em></a></strong>

<dd>
<p>Read the specified file, and act as if all text inside it was specified as
command line parameters.  Any relative paths are relative to the current
directory.  See also -F. Note -f is fairly standard across Verilog tools.</p>
</dd>
<dd>
<p>The file may contain // comments which are ignored to the end of the line.
Any $VAR, $(VAR), or ${VAR} will be replaced with the specified environment
variable.</p>
</dd>
</li>
<dt><strong><a name="gdbbt" class="item">--gdbbt</a></strong>

<dd>
<p>If --debug is specified, run Verilator underneath a GDB process and print
a backtrace on exit.  Without --debug or if GDB doesn't seem to work, this
flag is ignored.</p>
</dd>
</li>
<dt><strong><a name="help" class="item">--help</a></strong>

<dd>
<p>Displays this message and program version and exits.</p>
</dd>
</li>
<dt><strong><a name="idir" class="item">-I<em>dir</em></a></strong>

<dd>
<p>See -y.</p>
</dd>
</li>
<dt><strong><a name="if_depth_value" class="item">--if-depth <em>value</em></a></strong>

<dd>
<p>Rarely needed.  Set the depth at which the IFDEPTH warning will fire,
defaults to 0 which disables this warning.</p>
</dd>
</li>
<dt><strong><a name="incdir_dir" class="item">+incdir+<em>dir</em></a></strong>

<dd>
<p>See -y.</p>
</dd>
</li>
<dt><strong><a name="inhibit_sim" class="item">--inhibit-sim</a></strong>

<dd>
<p>Rarely needed.  Create a &quot;inhibitSim(bool)&quot; function to enable and disable
evaluation.  This allows an upper level testbench to disable modules that
are not important in a given simulation, without needing to recompile or
change the SystemC modules instantiated.</p>
</dd>
</li>
<dt><strong><a name="inline_mult_value" class="item">--inline-mult <em>value</em></a></strong>

<dd>
<p>Tune the inlining of modules.  The default value of 2000 specifies that up
to 2000 new operations may be added to the model by inlining, if more than
this number of operations would result, the module is not inlined.  Larger
values, or a value &lt;= 1 will inline everything, will lead to longer compile
times, but potentially faster runtimes.  This setting is ignored for very
small modules; they will always be inlined, if allowed.</p>
</dd>
</li>
<dt><strong><a name="ldflags_flags" class="item">-LDFLAGS <em>flags</em></a></strong>

<dd>
<p>Add specified C linker flags to the generated makefiles.  When make is run
on the generated makefile these will be passed to the C++ linker (ld)
*after* the primary file being linked.  This flag is called -LDFLAGS as
that's the traditional name in simulators; it's would have been better
called LDLIBS as that's the Makefile variable it controls.  (In Make,
LDFLAGS is before the first object, LDLIBS after.  -L libraries need to be
in the Make variable LDLIBS, not LDFLAGS.)</p>
</dd>
</li>
<dt><strong><a name="language_value" class="item">--language <em>value</em></a></strong>

<dd>
<p>Select the language to be used when first processing each Verilog file.
The language value must be &quot;1364-1995&quot;, &quot;1364-2001&quot;, &quot;1364-2001&quot;,
&quot;1364-2005&quot;, &quot;1800-2005&quot;, &quot;VAMS-2.3&quot;.  Verilator also allows the
non-standard &quot;1800+VAMS&quot; to allow both the full SystemVerilog and
Verilog-AMS keywords.</p>
</dd>
<dd>
<p>The --language flag is only recommended for legacy code, as the preferable
option is to edit the code to repair new keywords, or add appropriate
`begin_keywords.</p>
</dd>
</li>
<dt><strong><a name="libext_ext_ext" class="item">+libext+<em>ext</em>+<em>ext</em>...</a></strong>

<dd>
<p>Specify the extensions that should be used for finding modules.  If for
example module <em>x</em> is referenced, look in <em>x</em>.<em>ext</em>.  Note +libext+ is
fairly standard across Verilog tools.  Defaults to .v and .sv.</p>
</dd>
</li>
<dt><strong><a name="lint_only" class="item">--lint-only</a></strong>

<dd>
<p>Check the files for lint violations only, do not create any other output.</p>
</dd>
<dd>
<p>You may also want the -Wall option to enable messages that are considered
stylistic and not enabled by default.</p>
</dd>
<dd>
<p>If the design is not to be completely Verilated see also the --bbox-sys and
--bbox-unsup options.</p>
</dd>
</li>
<dt><strong><a name="mmd" class="item">--MMD</a></strong>

<dd>
<p>Enable creation of .d dependency files, used for make dependency detection,
similar to gcc -MMD option.  On by default, use --no-MMD to disable.</p>
</dd>
</li>
<dt><strong><a name="mp" class="item">--MP</a></strong>

<dd>
<p>When creating .d dependency files with --MMD, make phony targets.  Similar
to gcc -MP option.</p>
</dd>
</li>
<dt><strong><a name="mdir_directory" class="item">--Mdir <em>directory</em></a></strong>

<dd>
<p>Specifies the name of the Make object directory.  All generated files will
be placed in this directory.  If not specified, &quot;obj_dir&quot; is used.</p>
</dd>
</li>
<dt><strong><a name="mod_prefix_topname" class="item">--mod-prefix <em>topname</em></a></strong>

<dd>
<p>Specifies the name to prepend to all lower level classes.  Defaults to
the same as --prefix.</p>
</dd>
</li>
<dt><strong><a name="no_pins64" class="item">--no-pins64</a></strong>

<dd>
<p>Backward compatible alias for &quot;--pins-bv 33&quot;.</p>
</dd>
</li>
<dt><strong><a name="no_skip_identical" class="item">--no-skip-identical</a></strong>

<dd>
<p>Rarely needed.  Disables skipping execution of Verilator if all source
files are identical, and all output files exist with newer dates.</p>
</dd>
</li>
<dt><strong><a name="notimingchecks" class="item">+notimingchecks</a></strong>

<dd>
<p>Ignored for compatibility with other simulators.</p>
</dd>
</li>
<dt><strong><a name="o0" class="item">-O0</a></strong>

<dd>
<p>Disables optimization of the model.</p>
</dd>
</li>
<dt><strong><a name="o3" class="item">-O3</a></strong>

<dd>
<p>Enables slow optimizations.  This may reduce simulation runtimes at the
cost of compile time.  This currently sets --inline-mult -1.</p>
</dd>
</li>
<dt><strong><a name="ooptimization_letter" class="item">-O<em>optimization-letter</em></a></strong>

<dd>
<p>Rarely needed.  Enables or disables a specific optimizations, with the
optimization selected based on the letter passed.  A lowercase letter
disables an optimization, an upper case letter enables it.  This is
intended for debugging use only; see the source code for version-dependent
mappings of optimizations to -O letters.</p>
</dd>
</li>
<dt><strong><a name="o_executable" class="item">-o &lt;executable&gt;</a></strong>

<dd>
<p>Specify the name for the final executable built if using --exe.  Defaults
to the --prefix if not specified.</p>
</dd>
</li>
<dt><strong><a name="output_split_bytes" class="item">--output-split <em>bytes</em></a></strong>

<dd>
<p>Enables splitting the output .cpp/.sp files into multiple outputs.  When a
C++ file exceeds the specified number of operations, a new file will be
created at the next function boundary.  In addition, any slow routines will
be placed into __Slow files.  This accelerates compilation by as
optimization can be disabled on the slow routines, and the remaining files
can be compiled on parallel machines.  Using --output-split should have
only a trivial impact on performance.  With GCC 3.3 on a 2GHz Opteron,
--output-split 20000 will result in splitting into approximately
one-minute-compile chunks.</p>
</dd>
</li>
<dt><strong><a name="output_split_cfuncs_statements" class="item">--output-split-cfuncs <em>statements</em></a></strong>

<dd>
<p>Enables splitting functions in the output .cpp/.sp files into multiple
functions.  When a generated function exceeds the specified number of
operations, a new function will be created.  With --output-split, this will
enable GCC to compile faster, at a small loss in performance that gets
worse with decreasing split values.  Note that this option is stronger than
--output-split in the sense that --output-split will not split inside a
function.</p>
</dd>
</li>
<dt><strong><a name="pins64" class="item">--pins64</a></strong>

<dd>
<p>Backward compatible alias for &quot;--pins-bv 65&quot;.  Note that's a 65, not a 64.</p>
</dd>
</li>
<dt><strong><a name="pins_bv_width" class="item">--pins-bv <em>width</em></a></strong>

<dd>
<p>Specifies SystemC inputs/outputs of greater than or equal to <em>width</em> bits
wide should use sc_bv's instead of uint32/vluint64_t's.  The default is
&quot;--pins-bv 65&quot;.  Versions before Verilator 3.671 defaulted to &quot;--pins-bv
33&quot;.  The more sc_bv is used, the worse for performance.  Use the
&quot;/*verilator sc_bv*/&quot; attribute to select specific ports to be sc_bv.</p>
</dd>
</li>
<dt><strong><a name="pins_uint8" class="item">--pins-uint8</a></strong>

<dd>
<p>Specifies SystemC inputs/outputs that are smaller than the --pins-bv
setting and 8 bits or less should use uint8_t instead of uint32_t.
Likewise pins of width 9-16 will use uint16_t instead of uint32_t.</p>
</dd>
</li>
<dt><strong><a name="pipe_filter_command" class="item">--pipe-filter <em>command</em></a></strong>

<dd>
<p>Rarely needed and experimental.  Verilator will spawn the specified command
as a subprocess pipe, to allow the command to perform custom edits on the
Verilog code before it reaches Verilator.</p>
</dd>
<dd>
<p>Before reading each Verilog file, Verilator will pass the file name to the
subprocess' stdin with 'read_verilog &quot;&lt;filename&gt;&quot;'.  The filter may then
read the file and perform any filtering it desires, and feeds the new file
contents back to Verilator on stdout with 'Content-Length'.  Output to
stderr from the filter feeds through to Verilator's stdout and if the
filter exits with non-zero status Verilator terminates.  See the
t/t_pipe_filter test for an example.</p>
</dd>
<dd>
<p>To debug the output of the filter, try using the -E option to see
preprocessed output.</p>
</dd>
</li>
<dt><strong><a name="prefix_topname" class="item">--prefix <em>topname</em></a></strong>

<dd>
<p>Specifies the name of the top level class and makefile.  Defaults to V
prepended to the name of the --top-module switch, or V prepended to the
first Verilog filename passed on the command line.</p>
</dd>
</li>
<dt><strong><a name="profile_cfuncs" class="item">--profile-cfuncs</a></strong>

<dd>
<p>Modify the created C++ functions to support profiling.  The functions will
be minimized to contain one &quot;basic&quot; statement, generally a single always
block or wire statement.  (Note this will slow down the executable by ~5%.)
Furthermore, the function name will be suffixed with the basename of the
Verilog module and line number the statement came from.  This allows gprof
or oprofile reports to be correlated with the original Verilog source
statements.</p>
</dd>
</li>
<dt><strong><a name="private" class="item">--private</a></strong>

<dd>
<p>Opposite of --public.  Is the default; this option exists for backwards
compatibility.</p>
</dd>
</li>
<dt><strong><a name="psl" class="item">--psl</a></strong>

<dd>
<p>Enable PSL parsing.  Without this switch, PSL meta-comments are ignored.
See the --assert flag to enable all assertions, and --coverage-user to
enable functional coverage.</p>
</dd>
</li>
<dt><strong><a name="public" class="item">--public</a></strong>

<dd>
<p>This is only for historical debug use.  Using it may result in
mis-simulation of generated clocks.</p>
</dd>
<dd>
<p>Declares all signals and modules public.  This will turn off signal
optimizations as if all signals had a /*verilator public*/ comments and
inlining.  This will also turn off inlining as if all modules had a
/*verilator public_module*/, unless the module specifically enabled it with
/*verilator inline_module*/.</p>
</dd>
</li>
<dt><strong><a name="sc" class="item">--sc</a></strong>

<dd>
<p>Specifies SystemC output mode; see also --cc and -sp.</p>
</dd>
</li>
<dt><strong><a name="sp" class="item">--sp</a></strong>

<dd>
<p>Specifies SystemPerl output mode; see also --cc and -sc.</p>
</dd>
</li>
<dt><strong><a name="stats" class="item">--stats</a></strong>

<dd>
<p>Creates a dump file with statistics on the design in {prefix}__stats.txt.</p>
</dd>
</li>
<dt><strong><a name="sv" class="item">-sv</a></strong>

<dd>
<p>Specifies SystemVerilog language features should be enabled; equivalent to
&quot;--language 1800-2005&quot;.  This option is selected by default, it exists for
compatibility with other simulators.</p>
</dd>
</li>
<dt><strong><a name="top_module_topname" class="item">--top-module <em>topname</em></a></strong>

<dd>
<p>When the input Verilog contains more than one top level module, specifies
the name of the top level Verilog module to become the top, and sets the
default for if --prefix is not used.  This is not needed with standard
designs with only one top.</p>
</dd>
</li>
<dt><strong><a name="trace" class="item">--trace</a></strong>

<dd>
<p>Adds waveform tracing code to the model.  Verilator will generate
additional {prefix}__Trace*.cpp files that will need to be compiled.  In
addition verilated_vcd_sc.cpp (for SystemC traces) or verilated_vcd_c.cpp
(for both) must be compiled and linked in.  If using the Verilator
generated Makefiles, these will be added as source targets for you.  If
you're not using the Verilator makefiles, you will need to add these to
your Makefile manually.</p>
</dd>
<dd>
<p>Having tracing compiled in may result in some small performance losses,
even when waveforms are not turned on during model execution.</p>
</dd>
</li>
<dt><strong><a name="trace_depth_levels" class="item">--trace-depth <em>levels</em></a></strong>

<dd>
<p>Specify the number of levels deep to enable tracing, for example
--trace-level 1 to only see the top level's signals.  Defaults to the
entire model.  Using a small number will decrease visibility, but greatly
improve runtime and trace file size.</p>
</dd>
</li>
<dt><strong><a name="trace_max_array_depth" class="item">--trace-max-array <em>depth</em></a></strong>

<dd>
<p>Rarely needed.  Specify the maximum array depth of a signal that may be
traced.  Defaults to 32, as tracing large arrays may greatly slow traced
simulations.</p>
</dd>
</li>
<dt><strong><a name="trace_max_width_width" class="item">--trace-max-width <em>width</em></a></strong>

<dd>
<p>Rarely needed.  Specify the maximum bit width of a signal that may be
traced.  Defaults to 256, as tracing large vectors may greatly slow traced
simulations.</p>
</dd>
</li>
<dt><strong><a name="trace_underscore" class="item">--trace-underscore</a></strong>

<dd>
<p>Enable tracing of signals that start with an underscore. Normally, these
signals are not output during tracing.  See also --coverage-underscore.</p>
</dd>
</li>
<dt><strong><a name="uvar" class="item">-U<em>var</em></a></strong>

<dd>
<p>Undefines the given preprocessor symbol.</p>
</dd>
</li>
<dt><strong><a name="unroll_count_loops" class="item">--unroll-count <em>loops</em></a></strong>

<dd>
<p>Rarely needed.  Specifies the maximum number of loop iterations that may be
unrolled.  See also BLKLOOPINIT warning.</p>
</dd>
</li>
<dt><strong><a name="unroll_stmts_statements" class="item">--unroll-stmts <em>statements</em></a></strong>

<dd>
<p>Rarely needed.  Specifies the maximum number of statements in a loop for
that loop to be unrolled. See also BLKLOOPINIT warning.</p>
</dd>
</li>
<dt><strong><a name="unused_regexp_regexp" class="item">--unused-regexp <em>regexp</em></a></strong>

<dd>
<p>Rarely needed.  Specifies a simple regexp with * and ? that if a signal
name matches will suppress the UNUSED warning.  Defaults to &quot;*unused*&quot;.
Setting it to &quot;&quot; disables matching.</p>
</dd>
</li>
<dt><strong><a name="v" class="item">-V</a></strong>

<dd>
<p>Shows the verbose version, including configuration information compiled
into Verilator.  (Similar to perl -V.)</p>
</dd>
</li>
<dt><strong><a name="v_filename" class="item">-v <em>filename</em></a></strong>

<dd>
<p>Read the filename as a Verilog library.  Any modules in the file may be
used to resolve cell instantiations in the top level module, else ignored.
Note -v is fairly standard across Verilog tools.</p>
</dd>
</li>
<dt><strong><a name="wall" class="item">-Wall</a></strong>

<dd>
<p>Enable all warnings, including code style warnings that are normally
disabled by default.</p>
</dd>
</li>
<dt><strong><a name="werror_message" class="item">-Werror-<em>message</em></a></strong>

<dd>
<p>Convert the specified warning message into an error message.  This is
generally to discourage users from violating important site-wide rules, for
example <code>-Werror-NOUNOPTFLAT</code>.</p>
</dd>
</li>
<dt><strong><a name="wfuture_message" class="item">-Wfuture-<em>message</em></a></strong>

<dd>
<p>Rarely needed.  Suppress unknown Verilator comments or warning messages
with the given message code.  This is used to allow code written with
pragmas for a later version of Verilator to run under a older version; add
-Wfuture- arguments for each message code or comment that the new version
supports which the older version does not support.</p>
</dd>
</li>
<dt><strong><a name="wno_message" class="item">-Wno-<em>message</em></a></strong>

<dd>
<p>Disable the specified warning message.</p>
</dd>
</li>
<dt><strong><a name="wno_lint" class="item">-Wno-lint</a></strong>

<dd>
<p>Disable all lint related warning messages, and all style warnings.  This is
equivalent to &quot;-Wno-CASEINCOMPLETE -Wno-CASEOVERLAP -Wno-CASEX
-Wno-CASEWITHX -Wno-CMPCONST -Wno-ENDLABEL -Wno-IMPLICIT -Wno-LITENDIAN
-Wno-SYNCASYNCNET -Wno-UNDRIVEN -Wno-UNSIGNED -Wno-UNUSED -Wno-WIDTH&quot; plus
the list shown for Wno-style.</p>
</dd>
<dd>
<p>It is strongly recommended you cleanup your code rather than using this
option, it is only intended to be use when running test-cases of code
received from third parties.</p>
</dd>
</li>
<dt><strong><a name="wno_style" class="item">-Wno-style</a></strong>

<dd>
<p>Disable all code style related warning messages (note by default they are
already disabled).  This is equivalent to &quot;-Wno-DECLFILENAME -Wno-DEFPARAM
-Wno-INCABSPATH -Wno-SYNCASYNCNET -Wno-UNDRIVEN -Wno-UNUSED
-Wno-VARHIDDEN&quot;.</p>
</dd>
</li>
<dt><strong><a name="wno_fatal" class="item">-Wno-fatal</a></strong>

<dd>
<p>When warnings are detected, print them, but do not exit the simulator.</p>
</dd>
<dd>
<p>Having warning messages in builds is sloppy.  It is strongly recommended
you cleanup your code, use inline lint_off, or use -Wno-... flags rather
than using this option.</p>
</dd>
</li>
<dt><strong><a name="wwarn_message" class="item">-Wwarn-<em>message</em></a></strong>

<dd>
<p>Enables the specified warning message.</p>
</dd>
</li>
<dt><strong><a name="wwarn_lint" class="item">-Wwarn-lint</a></strong>

<dd>
<p>Enable all lint related warning messages (note by default they are already
enabled), but do not affect style messages.  This is equivalent to
&quot;-Wwarn-CASEINCOMPLETE -Wwarn-CASEOVERLAP -Wwarn-CASEX -Wwarn-CASEWITHX
-Wwarn-CMPCONST -Wwarn-ENDLABEL -Wwarn-IMPLICIT -Wwarn-LITENDIAN
-Wwarn-REALCVT -Wwarn-UNSIGNED -Wwarn-WIDTH&quot;.</p>
</dd>
</li>
<dt><strong><a name="wwarn_style" class="item">-Wwarn-style</a></strong>

<dd>
<p>Enable all code style related warning messages.  This is equivalent to
&quot;-Wwarn ASSIGNDLY -Wwarn-DECLFILENAME -Wwarn-DEFPARAM -Wwarn-INCABSPATH
-Wwarn-SYNCASYNCNET -Wwarn-UNDRIVEN -Wwarn-UNUSED -Wwarn-VARHIDDEN&quot;.</p>
</dd>
</li>
<dt><strong><a name="x_assign_0" class="item">-x-assign 0</a></strong>

<dt><strong><a name="x_assign_1" class="item">-x-assign 1</a></strong>

<dt><strong><a name="fast" class="item">-x-assign fast (default)</a></strong>

<dt><strong><a name="x_assign_unique" class="item">-x-assign unique</a></strong>

<dd>
<p>Controls the two-state value that is replaced when an assignment to X is
encountered.  -x-assign=fast, the default, converts all Xs to whatever is
best for performance.  -x-assign=0 converts all Xs to 0s, and is also fast.
-x-assign=1 converts all Xs to 1s, this is nearly as fast as 0, but more
likely to find reset bugs as active high logic will fire.  -x-assign=unique
will call a function to determine the value, this allows randomization of
all Xs to find reset bugs and is the slowest, but safest for finding reset
bugs in code.</p>
</dd>
<dd>
<p>If using -x-assign unique, you may want to seed your random number
generator such that each regression run gets a different randomization
sequence.  Use the system's srand48() or for Windows <code>srand()</code> function to do
this.  You'll probably also want to print any seeds selected, and code to
enable rerunning with that same seed so you can reproduce bugs.</p>
</dd>
</li>
<dt><strong><a name="y_dir" class="item">-y <em>dir</em></a></strong>

<dd>
<p>Add the directory to the list of directories that should be searched for
include files or libraries.  The three flags -y, +incdir and -I have
similar effect; +incdir and +y are fairly standard across Verilog tools while -I
is an alias for GCC compatibility.</p>
</dd>
<dd>
<p>Verilator defaults to the current directory (&quot;-y .&quot;) and any specified
--Mdir, though these default paths are used after any user specified
directories.  This allows '-y &quot;$(pwd)&quot;' to be used if absolute filenames
are desired for error messages instead of relative filenames.</p>
</dd>
</li>
</dl>
<p>
</p>
<hr />
<h1><a name="example_c___execution">EXAMPLE C++ EXECUTION</a></h1>
<p>We'll compile this example into C++.</p>
<pre>
    mkdir test_our
    cd test_our</pre>
<pre>
    cat &lt;&lt;EOF &gt;our.v
      module our;
         initial begin $display(&quot;Hello World&quot;); $finish; end
      endmodule
    EOF</pre>
<pre>
    cat &lt;&lt;EOF &gt;sim_main.cpp
      #include &quot;Vour.h&quot;
      #include &quot;verilated.h&quot;
      int main(int argc, char **argv, char **env) {
          Verilated::commandArgs(argc, argv);
          Vour* top = new Vour;
          while (!Verilated::gotFinish()) { top-&gt;eval(); }
          exit(0);
      }
    EOF</pre>
<p>If you installed Verilator from sources, or a tarball, but not as part of
your operating system (as an RPM), first you need to point to the kit:</p>
<pre>
    export VERILATOR_ROOT=/path/to/where/verilator/was/installed
    export PATH=$VERILATOR_ROOT/bin:$PATH</pre>
<p>Now we run Verilator on our little example.</p>
<pre>
    verilator -Wall --cc our.v --exe sim_main.cpp</pre>
<p>We can see the source code under the &quot;obj_dir&quot; directory.  See the FILES
section below for descriptions of some of the files that were created.</p>
<pre>
    ls -l obj_dir</pre>
<p>We then can compile it</p>
<pre>
    cd obj_dir
    make -j -f Vour.mk Vour</pre>
<p>(Verilator included a default compile rule and link rule, since we used
--exe and passed a .cpp file on the Verilator command line.  You can also
write your own compile rules, as we'll show in the SYSTEMC section.)</p>
<p>And now we run it</p>
<pre>
    cd ..
    obj_dir/Vour</pre>
<p>And we get as output</p>
<pre>
    Hello World
    - our.v:2: Verilog $finish</pre>
<p>Really, you're better off writing a Makefile to do all this for you.  Then,
when your source changes it will automatically run all of these steps.  See
the test_c directory in the distribution for an example.</p>
<p>
</p>
<hr />
<h1><a name="example_systemc_execution">EXAMPLE SYSTEMC EXECUTION</a></h1>
<p>This is an example similar to the above, but using SystemPerl.</p>
<pre>
    mkdir test_our_sc
    cd test_our_sc</pre>
<pre>
    cat &lt;&lt;EOF &gt;our.v
      module our (clk);
         input clk;  // Clock is required to get initial activation
         always @ (posedge clk)
            begin $display(&quot;Hello World&quot;); $finish; end
      endmodule
    EOF</pre>
<pre>
    cat &lt;&lt;EOF &gt;sc_main.cpp
      #include &quot;Vour.h&quot;
      int sc_main(int argc, char **argv) {
          Verilated::commandArgs(argc, argv);
          sc_clock clk (&quot;clk&quot;,10, 0.5, 3, true);
          Vour* top;
          top = new Vour(&quot;top&quot;);   // SP_CELL (top, Vour);
          top-&gt;clk(clk);           // SP_PIN  (top, clk, clk);
          while (!Verilated::gotFinish()) { sc_start(1, SC_NS); }
          exit(0);
      }
    EOF</pre>
<p>If you installed Verilator from sources, or a tarball, but not as part of
your operating system (as an RPM), first you need to point to the kit:</p>
<pre>
    export VERILATOR_ROOT=/path/to/where/verilator/was/installed
    export PATH=$VERILATOR_ROOT/bin:$PATH</pre>
<p>Now we run Verilator on our little example.</p>
<pre>
    verilator -Wall --sp our.v</pre>
<p>Then we convert the SystemPerl output to SystemC.</p>
<pre>
    cd obj_dir
    export SYSTEMPERL=/path/to/where/systemperl/kit/came/from
    $SYSTEMPERL/sp_preproc --preproc *.sp</pre>
<p>(You can also skip the above sp_preproc by getting pure SystemC from
Verilator by replacing the verilator --sp flag in the previous step with
-sc.)</p>
<p>We then can compile it</p>
<pre>
    make -j -f Vour.mk Vour__ALL.a
    make -j -f Vour.mk ../sc_main.o verilated.o</pre>
<p>And link with SystemC.  Note your path to the libraries may vary,
depending on the operating system.</p>
<pre>
    export SYSTEMC_LIBDIR=/path/to/where/libsystemc.a/exists
    g++ -L$SYSTEMC_LIBDIR ../sc_main.o Vour__ALL*.o verilated.o \
              -o Vour -lsystemc</pre>
<p>And now we run it</p>
<pre>
    cd ..
    obj_dir/Vour</pre>
<p>And we get the same output as the C++ example:</p>
<pre>
    Hello World
    - our.v:2: Verilog $finish</pre>
<p>Really, you're better off using a Makefile to do all this for you.  Then,
when your source changes it will automatically run all of these steps.  See
the test_sp directory in the distribution for an example.</p>
<p>
</p>
<hr />
<h1><a name="benchmarking___optimization">BENCHMARKING &amp; OPTIMIZATION</a></h1>
<p>For best performance, run Verilator with the &quot;-O3 -x-assign=fast
--noassert&quot; flags.  The -O3 flag will require longer compile times, and
-x-assign=fast may increase the risk of reset bugs in trade for
performance; see the above documentation for these flags.</p>
<p>Minor Verilog code changes can also give big wins.  You should not have any
UNOPTFLAT warnings from Verilator.  Fixing these warnings can result in
huge improvements; one user fixed their one UNOPTFLAT warning by making a
simple change to a clock latch used to gate clocks and gained a 60%
performance improvement.</p>
<p>Beyond that, the performance of a Verilated model depends mostly on your
C++ compiler and size of your CPU's caches.</p>
<p>By default, the lib/verilated.mk file has optimization turned off.  This is
for the benefit of new users, as it improves compile times at the cost of
runtimes.  To add optimization as the default, set one of three variables,
OPT, OPT_FAST, or OPT_SLOW in lib/verilated.mk. Or, just for one run, pass
them on the command line to make:</p>
<pre>
    make OPT_FAST=&quot;-O2&quot; -f Vour.mk Vour__ALL.a</pre>
<p>OPT_FAST specifies optimizations for those programs that are part of the
fast path, mostly code that is executed every cycle.  OPT_SLOW specifies
optimizations for slow-path files (plus tracing), which execute only
rarely, yet take a long time to compile with optimization on.  OPT
specifies overall optimization and affects all compiles, including those
OPT_FAST and OPT_SLOW affect.  For best results, use OPT=&quot;-O2&quot;, and link
with &quot;-static&quot;.  Nearly the same results can be had with much better
compile times with OPT_FAST=&quot;-O1 -fstrict-aliasing&quot;.</p>
<p>Unfortunately, using the optimizer with SystemC files can result in
compiles taking several minutes.  (The SystemC libraries have many little
inlined functions that drive the compiler nuts.)</p>
<p>For best results, use GCC 3.3 or newer.  GCC 3.2 and earlier have
optimization bugs around pointer aliasing detection, which can result in 2x
performance losses.</p>
<p>If you will be running many simulations on a single compile, investigate
feedback driven compilation.  With GCC, using -fprofile-arcs, then
-fbranch-probabilities will yield another 15% or so.</p>
<p>You may uncover further tuning possibilities by profiling the Verilog code.
Use Verilator's --profile-cfuncs, then GCC's -g -pg.  You can then run
either oprofile or gprof to see where in the C++ code the time is spent.
Run the gprof output through verilator_profcfunc and it will tell you what
Verilog line numbers on which most of the time is being spent.</p>
<p>When done, please let the author know the results.  I like to keep tabs on
how Verilator compares, and may be able to suggest additional improvements.</p>
<p>
</p>
<hr />
<h1><a name="files">FILES</a></h1>
<p>All output files are placed in the output directory name specified with the
-Mdir option, or &quot;obj_dir&quot; if not specified.</p>
<p>Verilator creates the following files in the output directory:</p>
<pre>
    {prefix}.mk                         // Make include file for compiling
    {prefix}_classes.mk                 // Make include file with class names</pre>
<p>For -cc and -sc mode, it also creates:</p>
<pre>
    {prefix}.cpp                        // Top level C++ file
    {prefix}.h                          // Top level header
    {prefix}{each_verilog_module}.cpp   // Lower level internal C++ files
    {prefix}{each_verilog_module}.h     // Lower level internal header files</pre>
<p>For -sp mode, instead of .cpp and .h it creates:</p>
<pre>
    {prefix}.sp                         // Top level SystemC file
    {prefix}{each_verilog_module}.sp    // Lower level internal SC files</pre>
<p>In certain optimization modes, it also creates:</p>
<pre>
    {prefix}__Dpi.h                     // DPI import and export declarations
    {prefix}__Inlines.h                 // Inline support functions
    {prefix}__Slow.cpp                  // Constructors and infrequent routines
    {prefix}__Syms.cpp                  // Global symbol table C++
    {prefix}__Syms.h                    // Global symbol table header
    {prefix}__Trace.cpp                 // Wave file generation code (--trace)
    {prefix}__cdc.txt                   // Clock Domain Crossing checks (--cdc)
    {prefix}__stats.txt                 // Statistics (--stats)</pre>
<p>It also creates internal files that can be mostly ignored:</p>
<pre>
    {each_verilog_module}.vpp           // Post-processed verilog (--debug)
    {prefix}.flags_vbin                 // Verilator dependencies
    {prefix}.flags_vpp                  // Pre-processor dependencies
    {prefix}__verFiles.dat              // Timestamps for skip-identical
    {prefix}{misc}.d                    // Make dependencies (-MMD)
    {prefix}{misc}.dot                  // Debugging graph files (--debug)
    {prefix}{misc}.tree                 // Debugging files (--debug)</pre>
<p>After running Make, the C++ compiler should produce the following:</p>
<pre>
    {prefix}                            // Final executable (w/--exe argument)
    {prefix}__ALL.a                     // Library of all Verilated objects
    {prefix}{misc}.o                    // Intermediate objects</pre>
<p>
</p>
<hr />
<h1><a name="environment">ENVIRONMENT</a></h1>
<dl>
<dt><strong><a name="objcache" class="item">OBJCACHE</a></strong>

<dd>
<p>Optionally specifies a caching or distribution program to place in front of
all runs of the C++ Compiler.  For example, &quot;objcache --read --write&quot;, or
&quot;ccache&quot;.  If using distcc, it would generally be run under either objcache
or ccache; see the documentation for those programs.</p>
</dd>
</li>
<dt><strong><a name="systemc" class="item">SYSTEMC</a></strong>

<dd>
<p>Deprecated.  Used only if SYSTEMC_INCLUDE or SYSTEMC_LIBDIR is not set.  If
set, specifies the directory containing the SystemC distribution.  If not
specified, it will come from a default optionally specified at configure
time (before Verilator was compiled).</p>
</dd>
</li>
<dt><strong><a name="systemc_arch" class="item">SYSTEMC_ARCH</a></strong>

<dd>
<p>Deprecated.  Used only if SYSTEMC_LIBDIR is not set.  Specifies the
architecture name used by the SystemC kit.  This is the part after the dash
in the lib-{...} directory name created by a 'make' in the SystemC
distribution.  If not set, Verilator will try to intuit the proper setting,
or use the default optionally specified at configure time (before Verilator
was compiled).</p>
</dd>
</li>
<dt><strong><a name="systemc_cxx_flags" class="item">SYSTEMC_CXX_FLAGS</a></strong>

<dd>
<p>Specifies additional flags that are required to be passed to GCC when
building the SystemC model.</p>
</dd>
</li>
<dt><strong><a name="systemc_include" class="item">SYSTEMC_INCLUDE</a></strong>

<dd>
<p>If set, specifies the directory containing the systemc.h header file. If
not specified, it will come from a default optionally specified at
configure time (before Verilator was compiled), or computed from
SYSTEMC/include.</p>
</dd>
</li>
<dt><strong><a name="systemc_libdir" class="item">SYSTEMC_LIBDIR</a></strong>

<dd>
<p>If set, specifies the directory containing the libsystemc.a library. If not
specified, it will come from a default optionally specified at configure
time (before Verilator was compiled), or compted from
SYSTEMC/lib-SYSTEMC_ARCH.</p>
</dd>
</li>
<dt><strong><a name="systemperl" class="item">SYSTEMPERL</a></strong>

<dd>
<p>Specifies the directory containing the SystemPerl distribution kit.  This
is used to find the SystemPerl library and include files.  If not
specified, it will come from a default optionally specified at configure
time (before Verilator was compiled).  See also SYSTEMPERL_INCLUDE.</p>
</dd>
</li>
<dt><strong><a name="systemperl_include" class="item">SYSTEMPERL_INCLUDE</a></strong>

<dd>
<p>Specifies the directory containing the Verilog-Perl include .cpp files,
from the src/ directory of the SystemPerl kit.  If not specified, it will
be computed from the SYSTEMPERL environment variable if it is set, and if
SYSTEMPERL is not set SYSTEMPERL_INCLUDE will come from a default
optionally specified at configure time (before Verilator was compiled).</p>
</dd>
</li>
<dt><strong><a name="vcs_home" class="item">VCS_HOME</a></strong>

<dd>
<p>If set, specifies the directory containing the Synopsys VCS distribution.
When set, a 'make test' in the Verilator distribution will also run VCS
baseline regression tests.</p>
</dd>
</li>
<dt><strong><a name="verilator_bin" class="item">VERILATOR_BIN</a></strong>

<dd>
<p>If set, specifies an alternative name of the Verilator binary.  May be used
for debugging and selecting between multiple operating system builds.</p>
</dd>
</li>
<dt><strong><a name="verilator_root" class="item">VERILATOR_ROOT</a></strong>

<dd>
<p>Specifies the directory containing the distribution kit.  This is used to
find the executable, Perl library, and include files.  If not specified, it
will come from a default optionally specified at configure time (before
Verilator was compiled).  It should not be specified if using a pre-compiled
Verilator RPM as the hardcoded value should be correct.</p>
</dd>
</li>
</dl>
<p>
</p>
<hr />
<h1><a name="connecting_to_c__">CONNECTING TO C++</a></h1>
<p>Verilator creates a .h and .cpp file for the top level module and all
modules under it.  See the test_c directory in the kit for an example.</p>
<p>After the modules are completed, there will be a <em>module</em>.mk file that may
be used with Make to produce a <em>module</em>__ALL.a file with all required
objects in it.  This is then linked with the user's top level to create the
simulation executable.</p>
<p>The user must write the top level of the simulation.  Here's a simple
example:</p>
<pre>
        #include &lt;verilated.h&gt;          // Defines common routines
        #include &quot;Vtop.h&quot;               // From Verilating &quot;top.v&quot;</pre>
<pre>
        Vtop *top;                      // Instantiation of module</pre>
<pre>
        vluint64_t main_time = 0;       // Current simulation time
        // This is a 64-bit integer to reduce wrap over issues and
        // allow modulus.  You can also use a double, if you wish.</pre>
<pre>
        double sc_time_stamp () {       // Called by $time in Verilog
            return main_time;           // converts to double, to match
                                        // what SystemC does    
        }</pre>
<pre>
        int main(int argc, char** argv) {
            Verilated::commandArgs(argc, argv);   // Remember args</pre>
<pre>
            top = new Vtop;             // Create instance</pre>
<pre>
            top-&gt;reset_l = 0;           // Set some inputs</pre>
<pre>
            while (!Verilated::gotFinish()) {
                if (main_time &gt; 10) {
                    top-&gt;reset_l = 1;   // Deassert reset
                }
                if ((main_time % 10) == 1) {
                    top-&gt;clk = 1;       // Toggle clock
                }
                if ((main_time % 10) == 6) {
                    top-&gt;clk = 0;
                }
                top-&gt;eval();            // Evaluate model
                cout &lt;&lt; top-&gt;out &lt;&lt; endl;       // Read a output
                main_time++;            // Time passes...
            }</pre>
<pre>
            top-&gt;final();               // Done simulating
            //    // (Though this example doesn't get here)
        }</pre>
<p>Note signals are read and written as member variables of the lower module.
You call the <code>eval()</code> method to evaluate the model.  When the simulation is
complete call the <code>final()</code> method to wrap up any SystemVerilog final blocks,
and complete any assertions.</p>
<p>
</p>
<hr />
<h1><a name="connecting_to_systemc">CONNECTING TO SYSTEMC</a></h1>
<p>Verilator will convert the top level module to a SC_MODULE.  This module
will plug directly into a SystemC netlist.</p>
<p>The SC_MODULE gets the same pinout as the Verilog module, with the
following type conversions: Pins of a single bit become bool.  Pins 2-32
bits wide become uint32_t's.  Pins 33-64 bits wide become sc_bv's or
vluint64_t's depending on the --no-pins64 switch.  Wider pins become sc_bv's.
(Uints simulate the fastest so are used where possible.)</p>
<p>Lower modules are not pure SystemC code.  This is a feature, as using the
SystemC pin interconnect scheme everywhere would reduce performance by an
order of magnitude.</p>
<p>
</p>
<hr />
<h1><a name="direct_programming_interface__dpi_">DIRECT PROGRAMMING INTERFACE (DPI)</a></h1>
<p>Verilator supports SystemVerilog Direct Programming Interface import and
export statements.  Only the SystemVerilog form (&quot;DPI-C&quot;) is supported, not
the original Synopsys-only DPI.</p>
<p>
</p>
<h2><a name="dpi_example">DPI Example</a></h2>
<p>In the SYSTEMC example above, if you wanted to import C++ functions into
Verilog, put in our.v:</p>
<pre>
   import &quot;DPI-C&quot; function integer add (input integer a, input integer b);</pre>
<pre>
   initial begin
      $display(&quot;%x + %x = %x&quot;, 1, 2, add(1,2));
   endtask</pre>
<p>Then after Verilating, Verilator will create a file Vour__Dpi.h with the
prototype to call this function:</p>
<pre>
    extern int add (int a, int b);</pre>
<p>From the sc_main.cpp file (or another .cpp file passed to the Verilator
command line, or the link), you'd then:</p>
<pre>
    #include &quot;svdpi.h&quot;
    #include &quot;Vour__Dpi.h&quot;
    int add (int a, int b) { return a+b; }</pre>
<p>
</p>
<h2><a name="dpi_system_task_functions">DPI System Task/Functions</a></h2>
<p>Verilator extends the DPI format to allow using the same scheme to
efficiently add system functions.  Simply use a dollar-sign prefixed system
function name for the import, but note it must be escaped.</p>
<pre>
   export &quot;DPI-C&quot; function integer \$myRand;</pre>
<pre>
   initial $display(&quot;myRand=%d&quot;, $myRand());</pre>
<p>Going the other direction, you can export Verilog tasks so they can be
called from C++:</p>
<pre>
   export &quot;DPI-C&quot; task publicSetBool;</pre>
<pre>
   task publicSetBool;
      input bit in_bool;
      var_bool = in_bool;
   endtask</pre>
<p>Then after Verilating, Verilator will create a file Vour__Dpi.h with the
prototype to call this function:</p>
<pre>
    extern bool publicSetBool(bool in_bool);</pre>
<p>From the sc_main.cpp file, you'd then:</p>
<pre>
    #include &quot;Vour__Dpi.h&quot;
    publicSetBool(value);</pre>
<p>Or, alternatively, call the function under the design class.  This isn't
DPI compatible but is easier to read and better supports multiple designs.</p>
<pre>
    #include &quot;Vour__Dpi.h&quot;
    Vour::publicSetBool(value);
    // or top-&gt;publicSetBool(value);</pre>
<p>
</p>
<h2><a name="dpi_display_functions">DPI Display Functions</a></h2>
<p>Verilator allows writing $display like functions using this syntax:</p>
<pre>
   import &quot;DPI-C&quot; function void
         \$my_display (input string formatted /*verilator sformat*/ );</pre>
<p>The /*verilator sformat*/ indicates that this function accepts a $display
like format specifier followed by any number of arguments to satisfy the
format.</p>
<p>
</p>
<h2><a name="dpi_context_functions">DPI Context Functions</a></h2>
<p>Verilator supports IEEE DPI Context Functions.  Context imports pass the
simulator context, including calling scope name, and filename and line
number to the C code.  For example, in Verilog:</p>
<pre>
   import &quot;DPI-C&quot; context function int dpic_line();
   initial $display(&quot;This is line %d, again, line %d\n&quot;, `line, dpic_line());</pre>
<p>This will call C++ code which may then use the svGet* functions to read
information, in this case the line number of the Verilog statement that
invoked the dpic_line function:</p>
<pre>
   int dpic_line() {
       // Get a scope:  svScope scope = svGetScope();</pre>
<pre>
       const char* scopenamep = svGetNameFromScope(scope);
       assert(scopenamep);</pre>
<pre>
       const char* filenamep = &quot;&quot;;
       int lineno = 0;
       if (svGetCallerInfo(&amp;filenamep, &amp;lineno)) {
           printf(&quot;dpic_line called from scope %s on line %d\n&quot;,
              scopenamep, lineno);
           return lineno;
       } else {
           return 0;
       }
   }</pre>
<p>See the IEEE Standard for more information.</p>
<p>
</p>
<h2><a name="dpi_header_isolation">DPI Header Isolation</a></h2>
<p>Verilator places the IEEE standard header files such as svdpi.h into a
separate include directory, vltstd (VeriLaTor STandarD).  When compiling
most applications $VERILATOR_ROOT/include/vltstd would be in the include
path along with the normal $VERILATOR_ROOT/include.  However, when
compiling Verilated models into other simulators which have their own
svdpi.h and similar standard files with different contents, the vltstd
directory should not be included to prevent picking up incompatible
definitions.</p>
<p>
</p>
<h2><a name="public_functions">Public Functions</a></h2>
<p>Instead of DPI exporting, there's also Verilator public functions, which
are slightly faster, but less compatible.</p>
<p>
</p>
<hr />
<h1><a name="verification_procedural_interface__vpi_">VERIFICATION PROCEDURAL INTERFACE (VPI)</a></h1>
<p>Verilator supports a very limited subset of the VPI.  This subset allows
inspection, examination, value change callbacks, and depositing of values
to public signals only.</p>
<p>To access signals via the VPI, Verilator must be told exactly which signals
are to be accessed.  This is done using the Verilator public pragmas
documented below.</p>
<p>Verilator has an important difference from an event based simulator; signal
values that are changed by the VPI will not immediately propagate their
values, instead the top level header file's <code>eval()</code> method must be called.
Normally this would be part of the normal evaluation (IE the next clock
edge), not as part of the value change.  This makes the performance of VPI
routines extremely fast compared to event based simulators, but can confuse
some test-benches that expect immediate propagation.</p>
<p>Note the VPI by it's specified implementation will always be much slower
than accessing the Verilator values by direct reference
(structure-&gt;module-&gt;signame), as the VPI accessors perform lookup in
functions at runtime requiring at best hundreds of instructions, while the
direct references are evaluated by the compiler and result in only a couple
of instructions.</p>
<p>
</p>
<h2><a name="vpi_example">VPI Example</a></h2>
<p>In the below example, we have readme marked read-only, and writeme which if
written from outside the model will have the same semantics as if it
changed on the specified clock edge.</p>
<pre>
    module t;
       reg readme   /*verilator public_flat_rd*/;
       reg writeme  /*verilator public_flat_rw @(posedge clk) */;
    endmodule</pre>
<p>There are many online tutorials and books on the VPI, but an example that
accesses the above would be:</p>
<p>void <code>read_and_check()</code> {
    vpiHandle vh1 = vpi_handle_by_name((PLI_BYTE8*)&quot;t.readme&quot;, NULL);
    if (!vh1) { error... }
    const char* name = vpi_get_str(vpiName, vh1);
    printf(&quot;Module name: %s\n&quot;);  // Prints &quot;readme&quot;</p>
<pre>
    s_vpi_value v;
    v.format = vpiIntVal;
    vpi_get_value(vh1, &amp;v);
    printf(&quot;Value of v: %d\n&quot;, v.value.integer);  // Prints &quot;readme&quot;
}</pre>
<p>
</p>
<hr />
<h1><a name="cross_compilation">CROSS COMPILATION</a></h1>
<p>Verilator supports cross-compiling Verilated code.  This is generally used
to run Verilator on a Linux system and produce C++ code that is then compiled
on Windows.</p>
<p>Cross compilation involves up to three different OSes.  The build system is
where you configured and compiled Verilator, the host system where you run
Verilator, and the target system where you compile the Verilated code and
run the simulation.</p>
<p>Currently, Verilator requires the build and host system type to be the
same, though the target system type may be different.  To support this,
./configure and make Verilator on the build system.  Then, run Verilator on
the host system.  Finally, the output of Verilator may be compiled on the
different target system.</p>
<p>To support this, none of the files that Verilator produces will reference
any configure generated build-system specific files, such as config.h
(which is renamed in Verilator to config_build.h to reduce confusion.)  The
disadvantage of this approach is that include/verilatedos.h must
self-detect the requirements of the target system, rather than using
configure.</p>
<p>The target system may also require edits to the Makefiles, the simple
Makefiles produced by Verilator presume the target system is the same type
as the build system.</p>
<p>
</p>
<h2><a name="cadence_nc_systemc_models">Cadence NC-SystemC Models</a></h2>
<p>Similar to compiling Verilated designs with gcc, Verilated designs may be
compiled inside other simulators that support C++ or SystemC models.  One
such simulator is Cadence's NC-SystemC, part of their Incisive Verification
Suite.  (Highly recommended.)</p>
<p>Using the example files above, the following command will build the model
underneath NC:</p>
<pre>
   cd obj_dir
   ncsc_run \
        sc_main.cpp \
        Vour__ALLcls.cpp \
        Vour__ALLsup.cpp \
        verilated.cpp</pre>
<p>For larger designs you'll want to automate this using makefiles, which pull
the names of the .cpp files to compile in from the make variables generated
in obj_dir/Vour_classes.mk.</p>
<p>
</p>
<hr />
<h1><a name="configuration_files">CONFIGURATION FILES</a></h1>
<p>In addition to the command line, warnings and other features may be
controlled by configuration files, typically named with the .vlt
extension. An example:</p>
<pre>
  `verilator_config
  lint_off -msg WIDTH
  lint_off -msg CASEX  -file &quot;silly_vendor_code.v&quot;</pre>
<p>This disables WIDTH warnings globally, and CASEX for a specific file.</p>
<p>Configuration files are parsed after the normal Verilog preprocessing, so
`ifdefs, `defines, and comments may be used as if it were normal Verilog
code.</p>
<p>The grammar of configuration commands is as follows:</p>
<dl>
<dt><strong><a name="verilator_config" class="item">`verilator_config</a></strong>

<dd>
<p>Take remaining text up the the next `verilog mode switch and treat it as
Verilator configuration commands.</p>
</dd>
</li>
<dt><strong><a name="coverage_off_file_filename_lines_line_line" class="item">coverage_off [-file &quot;&lt;filename&gt;&quot; [-lines &lt;line&gt; [ - &lt;line&gt; ]]]</a></strong>

<dd>
<p>Disable coverage for the specified filename (or wildcard with '*' or '?',
or all files if omitted) and range of line numbers (or all lines if
omitted).  Often used to ignore an entire module for coverage analysis
purposes.</p>
</dd>
</li>
<dt><strong><a name="lint_off_msg_message_file_filename_lines_line_line" class="item">lint_off [-msg &lt;message&gt;] [-file &quot;&lt;filename&gt;&quot; [-lines &lt;line&gt; [ - &lt;line&gt;]]]</a></strong>

<dd>
<p>Disables the specified lint warning, in the specified filename (or wildcard
with '*' or '?', or all files if omitted) and range of line numbers (or all
lines if omitted).</p>
</dd>
<dd>
<p>If the -msg is omitted, all lint warnings are disabled.  This will override
all later lint warning enables for the specified region.</p>
</dd>
</li>
<dt><strong><a name="tracing_off_file_filename_lines_line_line" class="item">tracing_off [-file &quot;&lt;filename&gt;&quot; [-lines &lt;line&gt; [ - &lt;line&gt; ]]]</a></strong>

<dd>
<p>Disable waveform tracing for all future signals declared in the specified
filename (or wildcard with '*' or '?', or all files if omitted) and range
of line numbers (or all lines if omitted).</p>
</dd>
</li>
</dl>
<p>
</p>
<hr />
<h1><a name="language_standard_support">LANGUAGE STANDARD SUPPORT</a></h1>
<p>
</p>
<h2><a name="verilog_2001__ieee_1364_2001__support">Verilog 2001 (IEEE 1364-2001) Support</a></h2>
<p>Verilator supports most Verilog 2001 language features.  This includes
signed numbers, &quot;always @*&quot;, generate statements, multidimensional arrays,
localparam, and C-style declarations inside port lists.</p>
<p>
</p>
<h2><a name="verilog_2005__ieee_1364_2005__support">Verilog 2005 (IEEE 1364-2005) Support</a></h2>
<p>Verilator supports most Verilog 2005 language features.  This includes the
`begin_keywords and `end_keywords compiler directives, $clog2, and the
uwire keyword.</p>
<p>
</p>
<h2><a name="systemverilog_2005__ieee_1800_2005__support">SystemVerilog 2005 (IEEE 1800-2005) Support</a></h2>
<p>Verilator currently has some support for SystemVerilog synthesis
constructs. As SystemVerilog features enter common usage they are added;
please file a bug if a feature you need is missing.</p>
<p>Verilator supports ==? and !=? operators, ++ and -- in some contexts,
$bits, $countones, $error, $fatal, $info, $isunknown, $onehot, $onehot0,
$unit, $warning, always_comb, always_ff, always_latch, bit, byte, chandle,
const, do-while, enum, export, final, import, int, logic, longint, package,
program, shortint, time, typedef, var, void, priority case/if, and unique
case/if.</p>
<p>It also supports .name and .* interconnection.</p>
<p>Verilator partially supports concurrent assert and cover statements; see
the enclosed coverage tests for the syntax which is allowed.</p>
<p>
</p>
<h2><a name="systemverilog_2009__ieee_1800_2009__support">SystemVerilog 2009 (IEEE 1800-2009) Support</a></h2>
<p>Verilator implements a full SystemVerilog 2009 preprocessor, including
function call-like preprocessor defines, default define arguments,
`__FILE__, `__LINE__ and `undefineall.</p>
<p>Verilator currently has some support for SystemVerilog 2009 synthesis
constructs. As SystemVerilog features enter common usage they are added;
please file a bug if a feature you need is missing.</p>
<p>
</p>
<h2><a name="verilog_ams_support">Verilog AMS Support</a></h2>
<p>Verilator implements a very small subset of Verilog AMS (Verilog Analog and
Mixed-Signal Extensions) with the subset corresponding to those VMS
keywords with near equivelents in the Verilog 2005 or SystemVerilog 2009
languages.</p>
<p>AMS parsing is enabled with &quot;--language VAMS&quot; or &quot;--language 1800+VAMS&quot;.</p>
<p>At present Verilator implements ceil, exp, floor, ln, log, pow, sqrt,
string, and wreal.</p>
<p>
</p>
<h2><a name="sugar_psl_support">Sugar/PSL Support</a></h2>
<p>Most future work is being directed towards improving SystemVerilog
assertions instead of PSL.  If you are using these PSL features, please
contact the author as they may be depreciated in future versions.</p>
<p>With the --assert switch, Verilator enables support of the Property
Specification Language (PSL), specifically the simple PSL subset without
time-branching primitives.  Verilator currently only converts PSL
assertions to simple &quot;if (...) error&quot; statements, and coverage statements
to increment the line counters described in the coverage section.</p>
<p>Verilator implements these keywords: assert, assume (same as assert),
default (for clocking), countones, cover, isunknown, onehot, onehot0,
report, and true.</p>
<p>Verilator implements these operators: -&gt; (logical if).</p>
<p>Verilator does not support SEREs yet.  All assertion and coverage
statements must be simple expressions that complete in one cycle.  PSL
vmode/vprop/vunits are not supported.  PSL statements must be in the module
they reference, at the module level where you would put an
initial... statement.</p>
<p>Verilator only supports (posedge CLK) or (negedge CLK), where CLK is the
name of a one bit signal.  You may not use arbitrary expressions as
assertion clocks.</p>
<p>
</p>
<h2><a name="synthesis_directive_assertion_support">Synthesis Directive Assertion Support</a></h2>
<p>With the --assert switch, Verilator reads any &quot;//synopsys full_case&quot; or
&quot;//synopsys parallel_case&quot; directives.  The same applies to any
&quot;//ambit synthesis&quot;, &quot;//cadence&quot; or &quot;//pragma&quot; directives of the same form.</p>
<p>When these synthesis directives are discovered, Verilator will either
formally prove the directive to be true, or failing that, will insert the
appropriate code to detect failing cases at runtime and print an &quot;Assertion
failed&quot; error message.</p>
<p>Verilator likewise also asserts any &quot;unique&quot; or &quot;priority&quot; SystemVerilog
keywords on case statements.  However, &quot;unique if&quot; and &quot;priority if&quot; are
currently simply ignored.</p>
<p>
</p>
<hr />
<h1><a name="language_extensions">LANGUAGE EXTENSIONS</a></h1>
<p>The following additional constructs are the extensions Verilator supports
on top of standard Verilog code.  Using these features outside of comments
or `ifdef's may break other tools.</p>
<dl>
<dt><strong><a name="file" class="item">`__FILE__</a></strong>

<dd>
<p>The __FILE__ define expands to the current filename as a string, like C++'s
__FILE__.  This was incorporated into to the 1800-2009 standard (but
supported by Verilator since 2006!)</p>
</dd>
</li>
<dt><strong><a name="line" class="item">`__LINE__</a></strong>

<dd>
<p>The __LINE__ define expands to the current filename as a string, like C++'s
__LINE__.  This was incorporated into to the 1800-2009 standard (but
supported by Verilator since 2006!)</p>
</dd>
</li>
<dt><strong><a name="error_string" class="item">`error <em>string</em></a></strong>

<dd>
<p>This will report an error when encountered, like C++'s #error.</p>
</dd>
</li>
<dt><strong><a name="_" class="item">_(<em>expr</em>)</a></strong>

<dd>
<p>A underline followed by an expression in parenthesis returns a Verilog
expression.  This is different from normal parenthesis in special contexts,
such as PSL expressions, and can be used to embed bit concatenation ({})
inside of PSL statements.</p>
</dd>
</li>
<dt><strong><a name="c" class="item">$c(<em>string</em>, ...);</a></strong>

<dd>
<p>The string will be embedded directly in the output C++ code at the point
where the surrounding Verilog code is compiled.  It may either be a
standalone statement (with a trailing ; in the string), or a function that
returns up to a 32-bit number (without a trailing ;). This can be used to
call C++ functions from your Verilog code.</p>
</dd>
<dd>
<p>String arguments will be put directly into the output C++ code.  Expression
arguments will have the code to evaluate the expression inserted.  Thus to
call a C++ function, $c(&quot;func(&quot;,a,&quot;)&quot;) will result in 'func(a)' in the
output C++ code.  For input arguments, rather than hard-coding variable
names in the string $c(&quot;func(a)&quot;), instead pass the variable as an
expression $c(&quot;func(&quot;,a,&quot;)&quot;).  This will allow the call to work inside
Verilog functions where the variable is flattened out, and also enable
other optimizations.</p>
</dd>
<dd>
<p>If you will be reading or writing any Verilog variables inside the C++
functions, the Verilog signals must be declared with /*verilator public*/.</p>
</dd>
<dd>
<p>You may also append an arbitrary number to $c, generally the width of the
output.  [signal_32_bits = $c32(&quot;...&quot;);] This allows for compatibility with
other simulators which require a differently named PLI function name for
each different output width.</p>
</dd>
</li>
<dt><strong><a name="_display_" class="item">$display, $write, $fdisplay, $fwrite, $sformat, $swrite</a></strong>

<dd>
<p>Format arguments may use C fprintf sizes after the % escape.  Per the
Verilog standard, %x prints a number with the natural width, and %0x prints
a number with minimum width.  Verilator extends this so %5x prints 5 digits
per the C standard (it's unspecified in Verilog).</p>
</dd>
</li>
<dt><strong><a name="coverage_block_off" class="item">`coverage_block_off</a></strong>

<dd>
<p>Specifies the entire begin/end block should be ignored for coverage analysis.
Same as /* verilator coverage_block_off */.</p>
</dd>
</li>
<dt><strong><a name="systemc_header" class="item">`systemc_header</a></strong>

<dd>
<p>Take remaining text up to the next `verilog or `systemc_... mode switch and
place it verbatim into the output .h file's header.  Despite the name of this
macro, this also works in pure C++ code.</p>
</dd>
</li>
<dt><strong><a name="systemc_ctor" class="item">`systemc_ctor</a></strong>

<dd>
<p>Take remaining text up to the next `verilog or `systemc_... mode switch and
place it verbatim into the C++ class constructor.  Despite the name of this
macro, this also works in pure C++ code.</p>
</dd>
</li>
<dt><strong><a name="systemc_dtor" class="item">`systemc_dtor</a></strong>

<dd>
<p>Take remaining text up to the next `verilog or `systemc_... mode switch and
place it verbatim into the C++ class destructor.  Despite the name of this
macro, this also works in pure C++ code.</p>
</dd>
</li>
<dt><strong><a name="systemc_interface" class="item">`systemc_interface</a></strong>

<dd>
<p>Take remaining text up to the next `verilog or `systemc_... mode switch and
place it verbatim into the C++ class interface.  Despite the name of this
macro, this also works in pure C++ code.</p>
</dd>
</li>
<dt><strong><a name="systemc_imp_header" class="item">`systemc_imp_header</a></strong>

<dd>
<p>Take remaining text up to the next `verilog or `systemc_... mode switch and
place it verbatim into the header of all files for this C++ class
implementation.  Despite the name of this macro, this also works in pure
C++ code.</p>
</dd>
</li>
<dt><strong><a name="systemc_implementation" class="item">`systemc_implementation</a></strong>

<dd>
<p>Take remaining text up to the next `verilog or `systemc_... mode switch and
place it verbatim into a single file of the C++ class implementation.
Despite the name of this macro, this also works in pure C++ code.</p>
</dd>
<dd>
<p>If you will be reading or writing any Verilog variables in the C++
functions, the Verilog signals must be declared with /*verilator public*/.
See also the public task feature; writing an accessor may result in cleaner
code.</p>
</dd>
</li>
<dt><strong><a name="verilator" class="item">`VERILATOR</a></strong>

<dt><strong><a name="verilator" class="item">`verilator</a></strong>

<dt><strong><a name="verilator3" class="item">`verilator3</a></strong>

<dd>
<p>The VERILATOR, verilator and verilator3 defines are set by default so you
may `ifdef around compiler specific constructs.</p>
</dd>
</li>
<dt><strong><a name="verilator_config2" class="item">`verilator_config</a></strong>

<dd>
<p>Take remaining text up the the next `verilog mode switch and treat it as
Verilator configuration commands.</p>
</dd>
</li>
<dt><strong><a name="verilog" class="item">`verilog</a></strong>

<dd>
<p>Switch back to processing Verilog code after a `systemc_... mode switch.
The Verilog code returns to the last language mode specified with
`begin_keywords, or SystemVerilog if none were specified.</p>
</dd>
</li>
<dt><strong><a name="verilator_clock_enable" class="item">/*verilator clock_enable*/</a></strong>

<dd>
<p>Used after a signal declaration to indicate the signal is used to gate a
clock, and the user takes responsibility for insuring there are no races
related to it.  (Typically by adding a latch, and running static timing
analysis.) This will cause the clock gate to be ignored in the scheduling
algorithm, improving performance.  It's also a good idea to enable the
IMPERFECTSCH warning, to insure all clock enables are properly recognized.</p>
</dd>
</li>
<dt><strong><a name="verilator_coverage_block_off" class="item">/*verilator coverage_block_off*/</a></strong>

<dd>
<p>Specifies the entire begin/end block should be ignored for coverage
analysis purposes.</p>
</dd>
</li>
<dt><strong><a name="verilator_coverage_off" class="item">/*verilator coverage_off*/</a></strong>

<dd>
<p>Specifies that following lines of code should have coverage disabled.
Often used to ignore an entire module for coverage analysis purposes.</p>
</dd>
</li>
<dt><strong><a name="verilator_coverage_on" class="item">/*verilator coverage_on*/</a></strong>

<dd>
<p>Specifies that following lines of code should have coverage re-enabled (if
appropriate --coverage flags are passed) after being disabled earlier with
/*verilator coverage_off*/.</p>
</dd>
</li>
<dt><strong><a name="verilator_inline_module" class="item">/*verilator inline_module*/</a></strong>

<dd>
<p>Specifies the module the comment appears in may be inlined into any modules
that use this module.  This is useful to speed up simulation time with some
small loss of trace visibility and modularity.  Note signals under inlined
submodules will be named <em>submodule</em>__DOT__<em>subsignal</em> as C++ does not
allow &quot;.&quot; in signal names.  SystemPerl when tracing such signals will
replace the __DOT__ with the period.</p>
</dd>
</li>
<dt><strong><a name="verilator_isolate_assignments" class="item">/*verilator isolate_assignments*/</a></strong>

<dd>
<p>Used after a signal declaration to indicate the assignments to this signal
in any blocks should be isolated into new blocks.  When there is a large
combinatorial block that is resulting in a UNOPTFLAT warning, attaching
this to the signal causing a false loop may clear up the problem.</p>
</dd>
<dd>
<p>IE, with the following</p>
</dd>
<dd>
<pre>
    reg splitme /* verilator isolate_assignments*/;
    // Note the placement of the semicolon above
    always @* begin
      if (....) begin
         splitme = ....;
         other assignments
      end
    end</pre>
</dd>
<dd>
<p>Verilator will internally split the block that assigns to &quot;splitme&quot; into
two blocks:</p>
</dd>
<dd>
<p>It would then internally break it into (sort of):</p>
</dd>
<dd>
<pre>
    // All assignments excluding those to splitme
    always @* begin
      if (....) begin
         other assignments
      end
    end
    // All assignments to splitme
    always @* begin
      if (....) begin
         splitme = ....;
      end
    end</pre>
</dd>
</li>
<dt><strong><a name="verilator_lint_off_msg" class="item">/*verilator lint_off <em>msg</em>*/</a></strong>

<dd>
<p>Disable the specified warning message for any warnings following the comment.</p>
</dd>
</li>
<dt><strong><a name="verilator_lint_on_msg" class="item">/*verilator lint_on <em>msg</em>*/</a></strong>

<dd>
<p>Re-enable the specified warning message for any warnings following the comment.</p>
</dd>
</li>
<dt><strong><a name="verilator_lint_restore" class="item">/*verilator lint_restore*/</a></strong>

<dd>
<p>After a /*verilator lint_save*/, pop the stack containing lint message
state.  Often this is useful at the bottom of include files.</p>
</dd>
</li>
<dt><strong><a name="verilator_lint_save" class="item">/*verilator lint_save*/</a></strong>

<dd>
<p>Push the current state of what lint messages are turned on or turned off to
a stack.  Later meta-comments may then lint_on or lint_off specific
messages, then return to the earlier message state by using /*verilator
lint_restore*/.  For example:</p>
</dd>
<dd>
<pre>
    // verilator lint_save
    // verilator lint_off SOME_WARNING
    ...  // code needing SOME_WARNING turned off
    // verilator lint_restore</pre>
</dd>
<dd>
<p>If SOME_WARNING was on before the lint_off, it will now be restored to on,
and if it was off before the lint_off it will remain off.</p>
</dd>
</li>
<dt><strong><a name="verilator_no_inline_task" class="item">/*verilator no_inline_task*/</a></strong>

<dd>
<p>Used in a function or task variable definition section to specify the
function or task should not be inlined into where it is used.  This may
reduce the size of the final executable when a task is used a very large
number of times.  For this flag to work, the task and tasks below it must
be pure; they cannot reference any variables outside the task itself.</p>
</dd>
</li>
<dt><strong><a name="verilator_public_variable" class="item">/*verilator public*/ (variable)</a></strong>

<dd>
<p>Used after an input, output, register, or wire declaration to indicate the
signal should be declared so that C code may read or write the value of the
signal.  This will also declare this module public, otherwise use
/*verilator public_flat*/.</p>
</dd>
<dd>
<p>Instead of using public variables, consider instead making a DPI or public
function that accesses the variable.  This is nicer as it provides an
obvious entry point that is also compatible across simulators.</p>
</dd>
</li>
<dt><strong><a name="verilator_public_task_function" class="item">/*verilator public*/ (task/function)</a></strong>

<dd>
<p>Used inside the declaration section of a function or task declaration to
indicate the function or task should be made into a C++ function, public to
outside callers.  Public tasks will be declared as a void C++ function,
public functions will get the appropriate non-void (bool, uint32_t, etc)
return type.  Any input arguments will become C++ arguments to the
function.  Any output arguments will become C++ reference arguments.  Any
local registers/integers will become function automatic variables on the
stack.</p>
</dd>
<dd>
<p>Wide variables over 64 bits cannot be function returns, to avoid exposing
complexities.  However, wide variables can be input/outputs; they will be
passed as references to an array of 32-bit numbers.</p>
</dd>
<dd>
<p>Generally, only the values of stored state (flops) should be written, as
the model will NOT notice changes made to variables in these functions.
(Same as when a signal is declared public.)</p>
</dd>
<dd>
<p>You may want to use DPI exports instead, as it's compatible with other
simulators.</p>
</dd>
</li>
<dt><strong><a name="verilator_public_flat_variable" class="item">/*verilator public_flat*/ (variable)</a></strong>

<dd>
<p>Used after an input, output, register, or wire declaration to indicate the
signal should be declared so that C code may read or write the value of the
signal.  This will not declare this module public, which means the name of
the signal or path to it may change based upon the module inlining which
takes place.</p>
</dd>
</li>
<dt><strong><a name="verilator_public_flat_rd_variable" class="item">/*verilator public_flat_rd*/ (variable)</a></strong>

<dd>
<p>Used after an input, output, register, or wire declaration to indicate the
signal should be declared public_flat (see above), but read-only.</p>
</dd>
</li>
<dt><strong><a name="verilator_public_flat_rw_edge_list_variable" class="item">/*verilator public_flat_rw @(&lt;edge_list&gt;) */ (variable)</a></strong>

<dd>
<p>Used after an input, output, register, or wire declaration to indicate the
signal should be declared public_flat_rd (see above), and also writable,
where writes should be considered to have the timing specified by the given
sensitivity edge list.</p>
</dd>
</li>
<dt><strong><a name="verilator_public_module" class="item">/*verilator public_module*/</a></strong>

<dd>
<p>Used after a module statement to indicate the module should not be inlined
(unless specifically requested) so that C code may access the module.
Verilator automatically sets this attribute when the module contains any
public signals or `systemc_ directives.  Also set for all modules when
using the --public switch.</p>
</dd>
</li>
<dt><strong><a name="verilator_sc_clock" class="item">/*verilator sc_clock*/</a></strong>

<dd>
<p>Rarely needed.  Used after an input declaration to indicate the signal
should be declared in SystemC as a sc_clock instead of a bool.  This was
needed in SystemC 1.1 and 1.2 only; versions 2.0 and later do not require
clock pins to be sc_clocks and this is no longer needed.</p>
</dd>
</li>
<dt><strong><a name="verilator_sc_bv" class="item">/*verilator sc_bv*/</a></strong>

<dd>
<p>Used after a port declaration.  It sets the port to be of sc_bv&lt;<em>width</em>&gt;
type, instead of bool, vluint32_t or vluint64_t.  This may be useful if
the port width is parametrized and different of such modules interface
a templated module (such as a transactor) or for other reasons.  In general
you should avoid using this attribute when not necessary as with increasing
usage of sc_bv the performance increases significantly.</p>
</dd>
</li>
<dt><strong><a name="verilator_sformat" class="item">/*verilator sformat*/</a></strong>

<dd>
<p>Attached to the final input of a function or task &quot;input string&quot; to
indicate the function or task should pass all remaining arguments through
$sformatf.  This allows creation of DPI functions with $display like
behavior.  See the test_regress/t/t_dpi_display.v file for an example.</p>
</dd>
</li>
<dt><strong><a name="verilator_tracing_off" class="item">/*verilator tracing_off*/</a></strong>

<dd>
<p>Disable waveform tracing for all future signals that are declared in this
module.  Often this is placed just after a primitive's module statement, so
that the entire module is not traced.</p>
</dd>
</li>
<dt><strong><a name="verilator_tracing_on" class="item">/*verilator tracing_on*/</a></strong>

<dd>
<p>Re-enable waveform tracing for all future signals that are declared.</p>
</dd>
</li>
</dl>
<p>
</p>
<hr />
<h1><a name="language_limitations">LANGUAGE LIMITATIONS</a></h1>
<p>There are some limitations and lack of features relative to a commercial
simulator, by intent.  User beware.</p>
<p>It is strongly recommended you use a lint tool before running this program.
Verilator isn't designed to easily uncover common mistakes that a lint
program will find for you.</p>
<p>
</p>
<h2><a name="synthesis_subset">Synthesis Subset</a></h2>
<p>Verilator supports only the Synthesis subset with a few minor additions
such as $stop, $finish and $display.  That is, you cannot use hierarchical
references, events or similar features of the Verilog language.  It also
simulates as Synopsys's Design Compiler would; namely a block of the form:</p>
<pre>
        always @ (x)   y = x &amp; z;</pre>
<p>This will recompute y when there is even a potential for change in x or a
change in z, that is when the flops computing x or z evaluate (which is
what Design Compiler will synthesize.)  A compliant simulator would only
calculate y if x changes.  Use verilog-mode's /*AS*/ or Verilog 2001's
always @* to reduce missing activity items.  Avoid putting $displays in
combo blocks, as they may print multiple times when not desired, even on
compliant simulators as event ordering is not specified.</p>
<p>
</p>
<h2><a name="dotted_cross_hierarchy_references">Dotted cross-hierarchy references</a></h2>
<p>Verilator supports dotted references to variables, functions and tasks in
different modules. However, references into named blocks and function-local
variables are not supported.  The portion before the dot must have a
constant value; for example a[2].b is acceptable, while a[x].b is not.</p>
<p>References into generated and arrayed instances use the instance names
specified in the Verilog standard; arrayed instances are named
{cellName}[{instanceNumber}] in Verilog, which becomes
{cellname}__BRA__{instanceNumber}__KET__ inside the generated C++ code.</p>
<p>Verilator creates numbered &quot;genblk&quot; when a begin: name is not specified
around a block inside a generate statement.  These numbers may differ
between other simulators, but the Verilog specification does not allow
users to use these names, so it should not matter.</p>
<p>If you are having trouble determining where a dotted path goes wrong, note
that Verilator will print a list of known scopes to help your debugging.</p>
<p>
</p>
<h2><a name="floating_point">Floating Point</a></h2>
<p>Floating Point (real) numbers are supported.</p>
<p>
</p>
<h2><a name="latches">Latches</a></h2>
<p>Verilator is optimized for edge sensitive (flop based) designs.  It will
attempt to do the correct thing for latches, but most performance
optimizations will be disabled around the latch.</p>
<p>
</p>
<h2><a name="time">Time</a></h2>
<p>All delays (#) are ignored, as they are in synthesis.</p>
<p>
</p>
<h2><a name="two_state">Two State</a></h2>
<p>Verilator is a two state simulator, not a four state simulator.  However, it
has two features which uncover most initialization bugs (including many that
a four state simulator will miss.)</p>
<p>First, assigning a variable to a X will actually assign the variable to a
random value (see the -x-assign switch.)  Thus if the value is actually
used, the random value should cause downstream errors.  Integers also
randomize, even though the Verilog 2001 specification says they initialize
to zero.</p>
<p>Identity comparisons (=== or !==) are converted to standard ==/!== when
neither side is a constant.  This may make the expression result differ
from a four state simulator.</p>
<p>All variables are initialized using a function.  By running several
random simulation runs you can determine that reset is working correctly.
On the first run, the function initializes variables to zero.  On the
second, have it initialize variables to one.  On the third and following
runs have it initialize them randomly.  If the results match, reset works.
(Note this is what the hardware will really do.)  In practice, just setting
all variables to one at startup finds most problems.</p>
<p>
</p>
<h2><a name="tri_inout">Tri/Inout</a></h2>
<p>Verilator converts some simple tristate structures into two state. An assignment
of the form:</p>
<pre>
    inout driver;
    wire driver = (enable) ? output_value : 1'bz;</pre>
<p>Will be converted to</p>
<pre>
    input driver__in;     // Value being driven in from &quot;external&quot; drivers
    output driver__en;    // True if driven from this module
    output driver__enout; // Value being driven from this module</pre>
<p>Pullup, pulldown, bufif0, bufif1, notif0, notif1 are also supported.
External logic will be needed to combine these signals with any external
drivers.</p>
<p>Tristate drivers are not supported inside functions and tasks; an inout
there will be considered a two state variable that is read and written
instead of a four state variable.</p>
<p>
</p>
<h2><a name="functions___tasks">Functions &amp; Tasks</a></h2>
<p>All functions and tasks will be inlined (will not become functions in C.)
The only support provided is for simple statements in tasks (which may
affect global variables).</p>
<p>Recursive functions and tasks are not supported.  All inputs and outputs
are automatic, as if they had the Verilog 2001 &quot;automatic&quot; keyword
prepended.  (If you don't know what this means, Verilator will do what you
probably expect -- what C does. The default behavior of Verilog is
different.)</p>
<p>
</p>
<h2><a name="generated_clocks">Generated Clocks</a></h2>
<p>Verilator attempts to deal with generated clocks correctly, however new
cases may turn up bugs in the scheduling algorithm.  The safest option is
to have all clocks as primary inputs to the model, or wires directly
attached to primary inputs.</p>
<p>
</p>
<h2><a name="ranges_must_be_big_bit_endian">Ranges must be big-bit-endian</a></h2>
<p>Bit ranges must be numbered with the MSB being numbered greater or the same
as the LSB.  Little-bit-endian busses [0:15] are not supported as they
aren't easily made compatible with C++.</p>
<p>
</p>
<h2><a name="gate_primitives">Gate Primitives</a></h2>
<p>The 2-state gate primitives (and, buf, nand, nor, not, or, xnor, xor) are
directly converted to behavioral equivalents.  The 3-state and MOS gate
primitives are not supported.  Tables are not supported.</p>
<p>
</p>
<h2><a name="specify_blocks">Specify blocks</a></h2>
<p>All specify blocks and timing checks are ignored.</p>
<p>
</p>
<h2><a name="array_initialization">Array Initialization</a></h2>
<p>When initializing a large array, you need to use non-delayed assignments.
Verilator will tell you when this needs to be fixed; see the BLKLOOPINIT
error for more information.</p>
<p>
</p>
<h2><a name="array_out_of_bounds">Array Out of Bounds</a></h2>
<p>Writing a memory element that is outside the bounds specified for the array
may cause a different memory element inside the array to be written
instead.  For power-of-2 sized arrays, Verilator will give a width warning
and the address.  For non-power-of-2-sizes arrays, index 0 will be written.</p>
<p>Reading a memory element that is outside the bounds specified for the array
will give a width warning and wrap around the power-of-2 size.  For
non-power-of-2 sizes, it will return a unspecified constant of the
appropriate width.</p>
<p>
</p>
<h2><a name="assertions">Assertions</a></h2>
<p>Verilator is beginning to add support for assertions.  Verilator currently
only converts assertions to simple &quot;if (...) error&quot; statements, and
coverage statements to increment the line counters described in the
coverage section.</p>
<p>Verilator does not support SEREs yet.  All assertion and coverage
statements must be simple expressions that complete in one cycle.
(Arguably SEREs are much of the point, but one must start somewhere.)</p>
<p>
</p>
<h2><a name="language_keyword_limitations">Language Keyword Limitations</a></h2>
<p>This section describes specific limitations for each language keyword.</p>
<dl>
<dt><strong><a name="file_line_begin_keywords_begin_keywords_begin_keywords_begin_keywords_begin_keywords_define_else_elsif_end_keywords_endif_error_ifdef_ifndef_include_line_systemc_ctor_systemc_dtor_systemc_header_systemc_imp_header_systemc_implementation_systemc_interface_timescale_undef_verilog" class="item">`__FILE__, `__LINE__, `begin_keywords, `begin_keywords, `begin_keywords,
`begin_keywords, `begin_keywords, `define, `else, `elsif, `end_keywords,
`endif, `error, `ifdef, `ifndef, `include, `line, `systemc_ctor,
`systemc_dtor, `systemc_header, `systemc_imp_header,
`systemc_implementation, `systemc_interface, `timescale, `undef, `verilog</a></strong>

<dd>
<p>Fully supported.</p>
</dd>
</li>
<dt><strong><a name="always_always_comb_always_ff_always_latch_and_assign_begin_buf_byte_case_casex_casez_default_defparam_do_while_else_end_endcase_endfunction_endgenerate_endmodule_endspecify_endtask_final_for_function_generate_genvar_if_initial_inout_input_int_integer_localparam_logic_longint_macromodule_module_nand_negedge_nor_not_or_output_parameter_posedge_reg_scalared_shortint_signed_supply0_supply1_task_time_tri_typedef_var_vectored_while_wire_xnor_xor" class="item">always, always_comb, always_ff, always_latch, and, assign, begin,
buf, byte, case, casex, casez, default, defparam, do-while, else, end,
endcase, endfunction, endgenerate, endmodule, endspecify, endtask, final,
for, function, generate, genvar, if, initial, inout, input, int, integer,
localparam, logic, longint, macromodule, module, nand, negedge, nor, not,
or, output, parameter, posedge, reg, scalared, shortint, signed, supply0,
supply1, task, time, tri, typedef, var, vectored, while, wire, xnor, xor</a></strong>

<dd>
<p>Generally supported.</p>
</dd>
</li>
<dt><strong><a name="operators" class="item">++, -- operators</a></strong>

<dd>
<p>Increment/decrement can only be used as standalone statements or in for
loops.  They cannot be used as side effect operators inside more complicate
expressions (&quot;a = b++;&quot;).</p>
</dd>
</li>
<dt><strong><a name="cast_operator" class="item">cast operator</a></strong>

<dd>
<p>Casting is supported only between simple scalar types, signed and unsigned,
not arrays nor structs.</p>
</dd>
</li>
<dt><strong><a name="chandle" class="item">chandle</a></strong>

<dd>
<p>Treated as a &quot;longint&quot;; does not yet warn about operations that are
specified as illegal on chandles.</p>
</dd>
</li>
<dt><strong><a name="disable" class="item">disable</a></strong>

<dd>
<p>Disable statements may be used only if the block being disabled is a block
the disable statement itself is inside.  This was commonly used to provide
loop break and continue functionality before SystemVerilog added the break
and continue keywords.</p>
</dd>
</li>
<dt><strong><a name="priority_if_unique_if" class="item">priority if, unique if</a></strong>

<dd>
<p>Priority and unique if's are treated as normal ifs and not asserted to be
full nor unique.</p>
</dd>
</li>
<dt><strong><a name="specify_specparam" class="item">specify specparam</a></strong>

<dd>
<p>All specify blocks and timing checks are ignored.</p>
</dd>
</li>
<dt><strong><a name="string" class="item">string</a></strong>

<dd>
<p>String is supported only to the point that they can be passed to DPI
imports.</p>
</dd>
</li>
<dt><strong><a name="timeunit_timeprecision" class="item">timeunit, timeprecision</a></strong>

<dd>
<p>All timing control statements are ignored.</p>
</dd>
</li>
<dt><strong><a name="uwire" class="item">uwire</a></strong>

<dd>
<p>Verilator does not perform warning checking on uwires, it treats the uwire
keyword as if it were the normal wire keyword.</p>
</dd>
</li>
<dt><strong><a name="_bits_" class="item">$bits, $countones, $error, $fatal, $finish, $info, $isunknown,
$onehot, $onehot0, $readmemb, $readmemh, $signed, $stime, $stop, $time,
$unsigned, $warning.</a></strong>

<dd>
<p>Generally supported.</p>
</dd>
</li>
<dt><strong>$display, $write, $fdisplay, $fwrite, $swrite</strong>

<dd>
<p>$display and friends must have a constant format string as the first
argument (as with C's printf).  The rare usage which lists variables
standalone without a format is not supported.</p>
</dd>
</li>
<dt><strong><a name="_displayb_" class="item">$displayb, $displayh, $displayo, $writeb, $writeh, $writeo, etc</a></strong>

<dd>
<p>The sized display functions are rarely used and so not supported.  Replace
them with a $write with the appropriate format specifier.</p>
</dd>
</li>
<dt><strong><a name="_finish_" class="item">$finish, $stop</a></strong>

<dd>
<p>The rarely used optional parameter to $finish and $stop is ignored.</p>
</dd>
</li>
<dt><strong><a name="_fopen_" class="item">$fopen, $fclose, $fdisplay, $feof, $fflush, $fgetc, $fgets, $fscanf, $fwrite</a></strong>

<dd>
<p>File descriptors passed to the file PLI calls must be file descriptors, not
MCDs, which includes the mode parameter to $fopen being mandatory.</p>
</dd>
</li>
<dt><strong><a name="_fscanf_" class="item">$fscanf, $sscanf</a></strong>

<dd>
<p>Only integer formats are supported; %e, %f, %m, %r, %v, and %z are not
supported.</p>
</dd>
</li>
<dt><strong><a name="_fullskew_" class="item">$fullskew, $hold, $nochange, $period, $recovery, $recrem, $removal,
$setup, $setuphold, $skew, $timeskew, $width</a></strong>

<dd>
<p>All specify blocks and timing checks are ignored.</p>
</dd>
</li>
<dt><strong><a name="_random" class="item">$random</a></strong>

<dd>
<p>$random does not support the optional argument to set the seed.  Use the
srand function in C to accomplish this, and note there is only one random
number generator (not one per module).</p>
</dd>
</li>
<dt><strong><a name="_readmemb_" class="item">$readmemb, $readmemh</a></strong>

<dd>
<p>Read memory commands should work properly.  Note Verilator and the Verilog
specification does not include support for readmem to multi-dimensional
arrays.</p>
</dd>
</li>
<dt><strong><a name="_test_plusargs_" class="item">$test$plusargs, $value$plusargs</a></strong>

<dd>
<p>Supported, but the instantiating C++/SystemC testbench must call</p>
</dd>
<dd>
<pre>
    Verilated::commandArgs(argc, argv);</pre>
</dd>
<dd>
<p>to register the command line before calling $test$plusargs or
$value$plusargs.</p>
</dd>
</li>
<dt><strong><a name="_timeformat" class="item">$timeformat</a></strong>

<dd>
<p>Not supported as Verilator needs to determine all formatting at compile
time.  Generally you can just ifdef them out for no ill effect.  Note also
VL_TIME_MULTIPLER can be defined at compile time to move the decimal point
when displaying all times, model wide.</p>
</dd>
</li>
</dl>
<p>
</p>
<hr />
<h1><a name="errors_and_warnings">ERRORS AND WARNINGS</a></h1>
<p>Warnings may be disabled in two ways.  First, when the warning is
printed it will include a warning code.  Simply surround the offending
line with a warn_off/warn_on pair:</p>
<pre>
        // verilator lint_off UNSIGNED
        if (`DEF_THAT_IS_EQ_ZERO &lt;= 3) $stop;
        // verilator lint_on UNSIGNED</pre>
<p>Warnings may also be globally disabled by invoking Verilator with the
<code>-Wno-warning</code> switch.  This should be avoided, as it removes all
checking across the designs, and prevents other users from compiling your
code without knowing the magic set of disables needed to successfully
compile your design.</p>
<p>List of all warnings:</p>
<dl>
<dt><strong><a name="assignin" class="item">ASSIGNIN</a></strong>

<dd>
<p>Error that an assignment is being made to an input signal.  This is almost
certainly a mistake, though technically legal.</p>
</dd>
<dd>
<pre>
    input a;
    assign a = 1'b1;</pre>
</dd>
<dd>
<p>Ignoring this warning will only suppress the lint check, it will simulate
correctly.</p>
</dd>
</li>
<dt><strong><a name="assigndly" class="item">ASSIGNDLY</a></strong>

<dd>
<p>Warns that you have an assignment statement with a delayed time in front of
it, for example:</p>
</dd>
<dd>
<pre>
    a &lt;= #100 b;
    assign #100 a = b;</pre>
</dd>
<dd>
<p>Ignoring this warning may make Verilator simulations differ from other
simulators, however at one point this was a common style so disabled by
default as a code style warning.</p>
</dd>
</li>
<dt><strong><a name="blkandnblk" class="item">BLKANDNBLK</a></strong>

<dd>
<p>BLKANDNBLK is an error that a variable comes from a mix of blocked and
non-blocking assignments.  Generally, this is caused by a register driven
by both combo logic and a flop:</p>
</dd>
<dd>
<pre>
      always @ (posedge clk)  foo[0] &lt;= ...
      always @* foo[1] = ...</pre>
</dd>
<dd>
<p>Simply use a different register for the flop:</p>
</dd>
<dd>
<pre>
      always @ (posedge clk)  foo_flopped[0] &lt;= ...
      always @* foo[0] = foo_flopped[0];
      always @* foo[1] = ...</pre>
</dd>
<dd>
<p>This is good coding practice anyways.</p>
</dd>
<dd>
<p>It is also possible to disable this error when one of the assignments is
inside a public task.</p>
</dd>
<dd>
<p>Ignoring this warning may make Verilator simulations differ from other
simulators.</p>
</dd>
</li>
<dt><strong><a name="blkseq" class="item">BLKSEQ</a></strong>

<dd>
<p>This indicates that a blocking assignment (=) is used in a sequential
block.  Generally non-blocking/delayed assignments (&lt;=) are used in
sequential blocks, to avoid the possibility of simulator races.  It can be
reasonable to do this if the generated signal is used ONLY later in the
same block, however this style is generally discouraged as it is error
prone.</p>
</dd>
<dd>
<pre>
      always @ (posedge clk)  foo = ...</pre>
</dd>
<dd>
<p>Disabled by default as this is a code style warning; it will simulate
correctly.</p>
</dd>
</li>
<dt><strong><a name="blkloopinit" class="item">BLKLOOPINIT</a></strong>

<dd>
<p>This indicates that the initialization of an array needs to use non-delayed
assignments.  This is done in the interest of speed; if delayed assignments
were used, the simulator would have to copy large arrays every cycle.  (In
smaller loops, loop unrolling allows the delayed assignment to work, though
it's a bit slower than a non-delayed assignment.)  Here's an example</p>
</dd>
<dd>
<pre>
        always @ (posedge clk)
            if (~reset_l) begin
                for (i=0; i&lt;`ARRAY_SIZE; i++) begin
                    array[i] = 0;        // Non-delayed for verilator
                end</pre>
</dd>
<dd>
<p>This message is only seen on large or complicated loops because Verilator
generally unrolls small loops.  You may want to try increasing
--unroll-count (and occasionally --unroll-stmts) which will raise the small
loop bar to avoid this error.</p>
</dd>
</li>
<dt><strong><a name="caseincomplete" class="item">CASEINCOMPLETE</a></strong>

<dd>
<p>Warns that inside a case statement there is a stimulus pattern for which
there is no case item specified.  This is bad style, if a case is
impossible, it's better to have a &quot;default: $stop;&quot; or just &quot;default: ;&quot; so
that any design assumption violations will be discovered in simulation.</p>
</dd>
<dd>
<p>Ignoring this warning will only suppress the lint check, it will simulate
correctly.</p>
</dd>
</li>
<dt><strong><a name="caseoverlap" class="item">CASEOVERLAP</a></strong>

<dd>
<p>Warns that inside a case statement you have case values which are detected
to be overlapping.  This is bad style, as moving the order of case values
will cause different behavior.  Generally the values can be respecified to
not overlap.</p>
</dd>
<dd>
<p>Ignoring this warning will only suppress the lint check, it will simulate
correctly.</p>
</dd>
</li>
<dt><strong><a name="casex" class="item">CASEX</a></strong>

<dd>
<p>Warns that it is simply better style to use casez, and <code>?</code> in place of
<code>x</code>'s.  See
<a href="http://www.sunburst-design.com/papers/CummingsSNUG1999Boston_FullParallelCase_rev1_1.pdf">http://www.sunburst-design.com/papers/CummingsSNUG1999Boston_FullParallelCase_rev1_1.pdf</a></p>
</dd>
<dd>
<p>Ignoring this warning will only suppress the lint check, it will simulate
correctly.</p>
</dd>
</li>
<dt><strong><a name="casewithx" class="item">CASEWITHX</a></strong>

<dd>
<p>Warns that a case statement contains a constant with a <code>x</code>.  Verilator is
two-state so interpret such items as always false.  Note a common error is
to use a <code>X</code> in a case or casez statement item; often what the user
instead intended is to use a casez with <code>?</code>.</p>
</dd>
<dd>
<p>Ignoring this warning will only suppress the lint check, it will simulate
correctly.</p>
</dd>
</li>
<dt><strong><a name="cdcrstlogic" class="item">CDCRSTLOGIC</a></strong>

<dd>
<p>With --cdc only, warns that asynchronous flop reset terms come from other
than primary inputs or flopped outputs, creating the potential for reset
glitches.</p>
</dd>
</li>
<dt><strong><a name="cmpconst" class="item">CMPCONST</a></strong>

<dd>
<p>Warns that you are comparing a value in a way that will always be constant.
For example &quot;X &gt; 1&quot; will always be true when X is a single bit wide.</p>
</dd>
<dd>
<p>Ignoring this warning will only suppress the lint check, it will simulate
correctly.</p>
</dd>
</li>
<dt><strong><a name="combdly" class="item">COMBDLY</a></strong>

<dd>
<p>Warns that you have a delayed assignment inside of a combinatorial block.
Using delayed assignments in this way is considered bad form, and may lead
to the simulator not matching synthesis.  If this message is suppressed,
Verilator, like synthesis, will convert this to a non-delayed assignment,
which may result in logic races or other nasties.  See
<a href="http://www.sunburst-design.com/papers/CummingsSNUG2000SJ_NBA_rev1_2.pdf">http://www.sunburst-design.com/papers/CummingsSNUG2000SJ_NBA_rev1_2.pdf</a></p>
</dd>
<dd>
<p>Ignoring this warning may make Verilator simulations differ from other
simulators.</p>
</dd>
</li>
<dt><strong><a name="declfilename" class="item">DECLFILENAME</a></strong>

<dd>
<p>Warns that a module or other declaration's name doesn't match the filename
with path and extension stripped that it is declared in.  The filename a
modules/interfaces/programs is declared in should match the name of the
module etc. so that -y directory searching will work.  This warning is
printed for only the first mismatching module in any given file, and -v
library files are ignored.</p>
</dd>
<dd>
<p>Disabled by default as this is a code style warning; it will simulate
correctly.</p>
</dd>
</li>
<dt><strong><a name="defparam" class="item">DEFPARAM</a></strong>

<dd>
<p>Warns that the &quot;defparam&quot; statement was deprecated in Verilog 2001 and all
designs should now be using the #(...) format to specify parameters.</p>
</dd>
<dd>
<p>Disabled by default as this is a code style warning; it will simulate
correctly.</p>
</dd>
</li>
<dt><strong><a name="endlabel" class="item">ENDLABEL</a></strong>

<dd>
<p>Warns that a label attached to a &quot;end&quot;-something statement does not match
the label attached to the block start.</p>
</dd>
<dd>
<p>Ignoring this warning will only suppress the lint check, it will simulate
correctly.</p>
</dd>
</li>
<dt><strong><a name="genclk" class="item">GENCLK</a></strong>

<dd>
<p>Warns that the specified signal is generated, but is also being used as a
clock.  Verilator needs to evaluate sequential logic multiple times in this
situation. In somewhat contrived cases having any generated clock can
reduce performance by almost a factor of two.  For fastest results,
generate ALL clocks outside in C++/SystemC and make them primary inputs to
your Verilog model.  (However once need to you have even one, don't sweat
additional ones.)</p>
</dd>
<dd>
<p>Ignoring this warning may make Verilator simulations differ from other
simulators.</p>
</dd>
</li>
<dt><strong><a name="ifdepth" class="item">IFDEPTH</a></strong>

<dd>
<p>Warns that if/if else statements have exceeded the depth specified with
--if-depth, as they are likely to result in slow priority encoders.  Unique
and priority if statements are ignored.  Solutions include changing the
code to a case statement, or a SystemVerilog 'unique if' or 'priority if'.</p>
</dd>
<dd>
<p>Disabled by default as this is a code style warning; it will simulate
correctly.</p>
</dd>
</li>
<dt><strong><a name="imperfectsch" class="item">IMPERFECTSCH</a></strong>

<dd>
<p>Warns that the scheduling of the model is not absolutely perfect, and some
manual code edits may result in faster performance.  This warning defaults
to off, and must be turned on explicitly before the top module statement is
processed.</p>
</dd>
</li>
<dt><strong><a name="implicit" class="item">IMPLICIT</a></strong>

<dd>
<p>Warns that a wire is being implicitly declared (it is a single bit wide
output from a sub-module.)  While legal in Verilog, implicit declarations
only work for single bit wide signals (not buses), do not allow using a
signal before it is implicitly declared by a cell, and can lead to dangling
nets.  A better option is the /*AUTOWIRE*/ feature of Verilog-Mode for
Emacs, available from <a href="http://www.veripool.org/">http://www.veripool.org/</a></p>
</dd>
<dd>
<p>Ignoring this warning will only suppress the lint check, it will simulate
correctly.</p>
</dd>
</li>
<dt><strong><a name="impure" class="item">IMPURE</a></strong>

<dd>
<p>Warns that a task or function that has been marked with /*verilator
no_inline_task*/ references variables that are not local to the task.
Verilator cannot schedule these variables correctly.</p>
</dd>
<dd>
<p>Ignoring this warning may make Verilator simulations differ from other
simulators.</p>
</dd>
</li>
<dt><strong><a name="incabspath" class="item">INCABSPATH</a></strong>

<dd>
<p>Warns that an `include filename specifies an absolute path.  This means the
code will not work on any other system with a different file system layout.
Instead of using absolute paths, relative paths (preferably without any
directory specified whatever) should be used, and +include used on the
command line to specify the top include source directory.</p>
</dd>
<dd>
<p>Disabled by default as this is a code style warning; it will simulate
correctly.</p>
</dd>
</li>
<dt><strong><a name="litendian" class="item">LITENDIAN</a></strong>

<dd>
<p>Warns that a vector is declared with little endian bit numbering
(i.e. [0:7]).  Big endian bit numbering is now the overwhelming standard,
and little numbering is now thus often due to simple oversight instead of
intent.</p>
</dd>
<dd>
<p>Ignoring this warning will only suppress the lint check, it will simulate
correctly.</p>
</dd>
</li>
<dt><strong><a name="moddup" class="item">MODDUP</a></strong>

<dd>
<p>Error that a module has multiple definitions.  Generally this indicates a
coding error, or a mistake in a library file and it's good practice to have
one module per file to avoid these issues.  For some gate level netlists
duplicates are unavoidable, and this error may be disabled.</p>
</dd>
</li>
<dt><strong><a name="multidriven" class="item">MULTIDRIVEN</a></strong>

<dd>
<p>Warns that the specified signal comes from multiple always blocks.  This is
often unsupported by synthesis tools, and is considered bad style.  It will
also cause longer runtimes due to reduced optimizations.</p>
</dd>
<dd>
<p>Ignoring this warning will only slow simulations, it will simulate
correctly.</p>
</dd>
</li>
<dt><strong><a name="multitop" class="item">MULTITOP</a></strong>

<dd>
<p>Error that there are multiple top level modules, that is modules not
instantiated by any other module.  Verilator only supports a single top
level, if you need more, create a module that wraps all of the top modules.</p>
</dd>
<dd>
<p>Often this error is because some low level cell is being read in, but is
not really needed.  The best solution is to insure that each module is in a
unique file by the same name.  Otherwise, make sure all library files are
read in as libraries with -v, instead of automatically with -y.</p>
</dd>
</li>
<dt><strong><a name="realcvt" class="item">REALCVT</a></strong>

<dd>
<p>Warns that a real number is being implicitly rounded to an integer, with
possible loss of precision.</p>
</dd>
</li>
<dt><strong><a name="redefmacro" class="item">REDEFMACRO</a></strong>

<dd>
<p>Warns that you have redefined the same macro with a different value, for
example:</p>
</dd>
<dd>
<pre>
    `define MACRO def1
    //...
    `define MACRO otherdef</pre>
</dd>
<dd>
<p>The best solution is to use a different name for the second macro.  If this
is not possible, add a undef to indicate the code is overriding the value:</p>
</dd>
<dd>
<pre>
    `define MACRO def1
    //...
    `undef MACRO
    `define MACRO otherdef</pre>
</dd>
</li>
<dt><strong><a name="stmtdly" class="item">STMTDLY</a></strong>

<dd>
<p>Warns that you have a statement with a delayed time in front of it, for
example:</p>
</dd>
<dd>
<pre>
    #100 $finish;</pre>
</dd>
<dd>
<p>Ignoring this warning may make Verilator simulations differ from other
simulators.</p>
</dd>
</li>
<dt><strong><a name="symrsvdword" class="item">SYMRSVDWORD</a></strong>

<dd>
<p>Error that a symbol matches a C++ reserved word and using this as a symbol
name would result in odd C compiler errors.  You may disable this error
message as you would disable warnings, but the symbol will be renamed by
Verilator to avoid the conflict.</p>
</dd>
</li>
<dt><strong><a name="syncasyncnet" class="item">SYNCASYNCNET</a></strong>

<dd>
<p>Warns that the specified net is used in at least two different always
statements with posedge/negedges (i.e. a flop).  One usage has the signal
in the sensitivity list and body, probably as an async reset, and the other
usage has the signal only in the body, probably as a sync reset.  Mixing
sync and async resets is usually a mistake.  The warning may be disabled
with a lint_off pragma around the net, or either flopped block.</p>
</dd>
<dd>
<p>Disabled by default as this is a code style warning; it will simulate
correctly.</p>
</dd>
</li>
<dt><strong><a name="tasknsvar" class="item">TASKNSVAR</a></strong>

<dd>
<p>Error when a call to a task or function has a output from that task tied to
a non-simple signal.  Instead connect the task output to a temporary signal
of the appropriate width, and use that signal to set the appropriate
expression as the next statement.  For example:</p>
</dd>
<dd>
<pre>
      task foo; output sig; ... endtask
      always @* begin
           foo(bus_we_select_from[2]);   // Will get TASKNSVAR error
      end</pre>
</dd>
<dd>
<p>Change this to:</p>
</dd>
<dd>
<pre>
      reg foo_temp_out;
      always @* begin
           foo(foo_temp_out);
           bus_we_select_from[2] = foo_temp_out;
      end</pre>
</dd>
<dd>
<p>Verilator doesn't do this conversion for you, as some more complicated
cases would result in simulator mismatches.</p>
</dd>
</li>
<dt><strong><a name="undriven" class="item">UNDRIVEN</a></strong>

<dd>
<p>Warns that the specified signal is never sourced.  Verilator is fairly
liberal in the usage calculations; making a signal public, or loading only
a single array element marks the entire signal as driven.</p>
</dd>
<dd>
<p>Disabled by default as this is a code style warning; it will simulate
correctly.</p>
</dd>
</li>
<dt><strong><a name="unopt" class="item">UNOPT</a></strong>

<dd>
<p>Warns that due to some construct, optimization of the specified signal or
block is disabled.  The construct should be cleaned up to improve runtime.</p>
</dd>
<dd>
<p>A less obvious case of this is when a module instantiates two submodules.
Inside submodule A, signal I is input and signal O is output.  Likewise in
submodule B, signal O is an input and I is an output.  A loop exists and a
UNOPT warning will result if AI &amp; AO both come from and go to combinatorial
blocks in both submodules, even if they are unrelated always blocks.  This
affects performance because Verilator would have to evaluate each submodule
multiple times to stabilize the signals crossing between the modules.</p>
</dd>
<dd>
<p>Ignoring this warning will only slow simulations, it will simulate
correctly.</p>
</dd>
</li>
<dt><strong><a name="unoptflat" class="item">UNOPTFLAT</a></strong>

<dd>
<p>Warns that due to some construct, optimization of the specified signal is
disabled.  The signal specified includes a complete scope to the signal; it
may be only one particular usage of a multiply instantiated block.  The
construct should be cleaned up to improve runtime; two times better
performance may be possible by fixing these warnings.</p>
</dd>
<dd>
<p>Unlike the UNOPT warning, this occurs after netlist flattening, and
indicates a more basic problem, as the less obvious case described under
UNOPT does not apply.</p>
</dd>
<dd>
<p>Often UNOPTFLAT is caused by logic that isn't truly circular as viewed by
synthesis which analyzes interconnection per-bit, but is circular to
simulation which analyzes per-bus:</p>
</dd>
<dd>
<pre>
      wire [2:0] x = {x[1:0],shift_in};</pre>
</dd>
<dd>
<p>This statement needs to be evaluated multiple times, as a change in
&quot;shift_in&quot; requires &quot;x&quot; to be computed 3 times before it becomes stable.
This is because a change in &quot;x&quot; requires &quot;x&quot; itself to change value, which
causes the warning.</p>
</dd>
<dd>
<p>For significantly better performance, split this into 2 separate signals:</p>
</dd>
<dd>
<pre>
      wire [2:0] xout = {x[1:0],shift_in};</pre>
</dd>
<dd>
<p>and change all receiving logic to instead receive &quot;xout&quot;.  Alternatively,
change it to</p>
</dd>
<dd>
<pre>
      wire [2:0] x = {xin[1:0],shift_in};</pre>
</dd>
<dd>
<p>and change all driving logic to instead drive &quot;xin&quot;.</p>
</dd>
<dd>
<p>With this change this assignment needs to be evaluated only once.  These
sort of changes may also speed up your traditional event driven simulator,
as it will result in fewer events per cycle.</p>
</dd>
<dd>
<p>The most complicated UNOPTFLAT path we've seen was due to low bits of a bus
being generated from an always statement that consumed high bits of the
same bus processed by another series of always blocks.  The fix is the
same; split it into two separate signals generated from each block.</p>
</dd>
<dd>
<p>The UNOPTFLAT warning may also be due to clock enables, identified from the
reported path going through a clock gating cell.  To fix these, use the
clock_enable meta comment described above.</p>
</dd>
<dd>
<p>The UNOPTFLAT warning may also occur where outputs from a block of logic
are independent, but occur in the same always block.  To fix this, use the
isolate_assignments meta comment described above.</p>
</dd>
<dd>
<p>Ignoring this warning will only slow simulations, it will simulate
correctly.</p>
</dd>
</li>
<dt><strong><a name="unsigned" class="item">UNSIGNED</a></strong>

<dd>
<p>Warns that you are comparing a unsigned value in a way that implies it is
signed, for example &quot;X &lt; 0&quot; will always be true when X is unsigned.</p>
</dd>
<dd>
<p>Ignoring this warning will only suppress the lint check, it will simulate
correctly.</p>
</dd>
</li>
<dt><strong><a name="unused" class="item">UNUSED</a></strong>

<dd>
<p>Warns that the specified signal is never sinked.  Verilator is fairly
liberal in the usage calculations; making a signal public, a signal
matching --unused-regexp (&quot;*unused*&quot;) or accessing only a single array
element marks the entire signal as used.</p>
</dd>
<dd>
<p>Disabled by default as this is a code style warning; it will simulate
correctly.</p>
</dd>
<dd>
<p>A recommended style for unused nets is to put at the bottom of a file code
similar to the following:</p>
</dd>
<dd>
<pre>
    wire _unused_ok = &amp;{1'b0,
                        sig_not_used_a,
                        sig_not_used_yet_b,  // To be fixed
                        1'b0};</pre>
</dd>
<dd>
<p>The reduction AND and constant zeros mean the net will always be zero, so
won't use simulation time.  The redundant leading and trailing zeros avoid
syntax errors if there are no signals between them.  The magic name
&quot;unused&quot; (-unused-regexp) is recognized by Verilator and suppresses
warnings; if using other lint tools, either teach to tool to ignore signals
with &quot;unused&quot; in the name, or put the appropriate lint_off around the wire.
Having unused signals in one place makes it easy to find what is unused,
and reduces the number of lint_off pragmas, reducing bugs.</p>
</dd>
</li>
<dt><strong><a name="varhidden" class="item">VARHIDDEN</a></strong>

<dd>
<p>Warns that a task, function, or begin/end block is declaring a variable by
the same name as a variable in the upper level module or begin/end block
(thus hiding the upper variable from being able to be used.)  Rename the
variable to avoid confusion when reading the code.</p>
</dd>
<dd>
<p>Disabled by default as this is a code style warning; it will simulate
correctly.</p>
</dd>
</li>
<dt><strong><a name="width" class="item">WIDTH</a></strong>

<dd>
<p>Warns that based on width rules of Verilog, two operands have different
widths.  Verilator generally can intuit the common usages of widths, and
you shouldn't need to disable this message like you do with most lint
programs.  Generally other than simple mistakes, you have two solutions:</p>
</dd>
<dd>
<p>If it's a constant 0 that's 32 bits or less, simply leave it
unwidthed. Verilator considers zero to be any width needed.</p>
</dd>
<dd>
<p>Concatenate leading zeros when doing arithmetic.  In the statement</p>
</dd>
<dd>
<pre>
        wire [5:0] plus_one = from[5:0] + 6'd1 + carry[0];</pre>
</dd>
<dd>
<p>The best fix, which clarifies intent and will also make all tools happy is:</p>
</dd>
<dd>
<pre>
        wire [5:0] plus_one = from[5:0] + 6'd1 + {5'd0,carry[0]};</pre>
</dd>
<dd>
<p>Ignoring this warning will only suppress the lint check, it will simulate
correctly.</p>
</dd>
</li>
<dt><strong><a name="widthconcat" class="item">WIDTHCONCAT</a></strong>

<dd>
<p>Warns that based on width rules of Verilog, a concatenate or replication
has an indeterminate width.  In most cases this violates the Verilog rule
that widths inside concatenates and replicates must be sized, and should be
fixed in the code.</p>
</dd>
<dd>
<pre>
    wire [63:0] concat = {1,2};</pre>
</dd>
<dd>
<p>An example where this is technically legal (though still bad form) is:</p>
</dd>
<dd>
<pre>
    parameter PAR = 1;
    wire [63:0] concat = {PAR,PAR};</pre>
</dd>
<dd>
<p>The correct fix is to either size the 1 (&quot;32'h1&quot;), or add the width to the
parameter definition (&quot;parameter [31:0]&quot;), or add the width to the
parameter usage (&quot;{PAR[31:0],PAR[31:0]}&quot;.</p>
</dd>
</li>
</dl>
<p>The following describes the less obvious errors:</p>
<dl>
<dt><strong><a name="internal_error" class="item">Internal Error</a></strong>

<dd>
<p>This error should never occur first, though may occur if earlier warnings
or error messages have corrupted the program.  If there are no other
warnings or errors, submit a bug report.</p>
</dd>
</li>
<dt><strong><a name="unsupported" class="item">Unsupported: ....</a></strong>

<dd>
<p>This error indicates that you are using a Verilog language construct
that is not yet supported in Verilator.  See the Limitations chapter.</p>
</dd>
</li>
<dt><strong><a name="verilated_model_didn_t_converge" class="item">Verilated model didn't converge</a></strong>

<dd>
<p>Verilator sometimes has to evaluate combinatorial logic multiple times,
usually around code where a UNOPTFLAT warning was issued, but disabled.
For example:</p>
</dd>
<dd>
<pre>
   always @ (a)  b=~a;
   always @ (b)  a=b</pre>
</dd>
<dd>
<p>will toggle forever and thus the executable will give the didn't converge
error to prevent an infinite loop.</p>
</dd>
<dd>
<p>To debug this, run Verilator with --profile-cfuncs.  Run make on the
generated files with &quot;OPT=-DVL_DEBUG&quot;. Then call Verilated::debug(1) in
your main.cpp.</p>
</dd>
<dd>
<p>This will cause each change in a variable to print a message.  Near the
bottom you'll see the code and variable that causes the problem.  For the
program above:</p>
</dd>
<dd>
<pre>
        CHANGE: filename.v:1: b
        CHANGE: filename.v:2: a</pre>
</dd>
</li>
</dl>
<p>
</p>
<hr />
<h1><a name="faq_frequently_asked_questions">FAQ/FREQUENTLY ASKED QUESTIONS</a></h1>
<dl>
<dt><strong><a name="does_it_run_under_windows" class="item">Does it run under Windows?</a></strong>

<dd>
<p>Yes, using Cygwin.  Verilated output should also compile under Microsoft
Visual C++ Version 7 or newer, but this is not tested by the author.</p>
</dd>
</li>
<dt><strong><a name="can_you_provide_binaries" class="item">Can you provide binaries?</a></strong>

<dd>
<p>Verilator is available as a RPM for SuSE, Fedora, and perhaps other
systems; this is done by porters and may slightly lag the primary
distribution.  If there isn't a binary build for your distribution, how
about you set one up?  Please contact the authors for assistance.</p>
</dd>
<dd>
<p>Note people sometimes request binaries when they are having problems with
their C++ compiler. Alas, binaries won't help this, as in the end a fully
working C++ compiler is required to compile the output of Verilator.</p>
</dd>
</li>
<dt><strong><a name="than" class="item">How can it be faster than (name-the-simulator)?</a></strong>

<dd>
<p>Generally, the implied part of the question is &quot;... with all of their
manpower they can put into it.&quot;</p>
</dd>
<dd>
<p>Most commercial simulators have to be Verilog compliant, meaning event
driven.  This prevents them from being able to reorder blocks and make
netlist-style optimizations, which are where most of the gains come from.</p>
</dd>
<dd>
<p>Non-compliance shouldn't be scary.  Your synthesis program isn't compliant,
so your simulator shouldn't have to be -- and Verilator is closer to the
synthesis interpretation, so this is a good thing for getting working
silicon.</p>
</dd>
</li>
<dt><strong><a name="will_verilator_output_remain_under_my_own_copyright" class="item">Will Verilator output remain under my own copyright?</a></strong>

<dd>
<p>Yes, it's just like using GCC on your programs; this is why Verilator uses
the &quot;GNU *Lesser* Public License Version 3&quot; instead of the more typical
&quot;GNU Public License&quot;.  See the licenses for details, but in brief, if you
change Verilator itself or the header files Verilator includes, you must
make the source code available under the GNU Lesser Public License.
However, Verilator output (the Verilated code) only &quot;include&quot;s the licensed
files, and so you are NOT required to release any output from Verilator.</p>
</dd>
<dd>
<p>You also have the option of using the Perl Artistic License, which again
does not require you release your Verilog or generated code, and also
allows you to modify Verilator for internal use without distributing the
modified version.  But please contribute back to the community!</p>
</dd>
<dd>
<p>One limit is that you cannot under either license release a commercial
Verilog simulation product incorporating Verilator without making the
source code available.</p>
</dd>
<dd>
<p>As is standard with Open Source, contributions back to Verilator will be
placed under the Verilator copyright and LGPL/Artistic license.  Small test
cases will be released into the public domain so they can be used anywhere,
large tests under the LGPL/Artistic, unless requested otherwise.</p>
</dd>
</li>
<dt><strong><a name="why_is_verilation_so_slow" class="item">Why is Verilation so slow?</a></strong>

<dd>
<p>Verilator needs more memory than the resulting simulator will require, as
Verilator creates internally all of the state of the resulting simulator in
order to optimize it.  If it takes more than a minute or so (and you're not
using --debug since debug is disk bound), see if your machine is paging;
most likely you need to run it on a machine with more memory.  Verilator is
a full 64-bit application and may use more than 4GB, but about 1GB is the
maximum typically needed.</p>
</dd>
</li>
<dt><strong><a name="waveforms" class="item">How do I generate waveforms (traces) in C++?</a></strong>

<dd>
<p>See the next question for tracing in SystemC mode.</p>
</dd>
<dd>
<p>Add the --trace switch to Verilator, and in your top level C code, call
Verilated::traceEverOn(true).  Then create a VerilatedVcdC object, and
in your main loop call &quot;trace_object-&gt;dump(time)&quot; every time step, and
finally call &quot;trace_object-&gt;close()&quot;.  For an example, see below and the
test_c/sim_main.cpp file of the distribution.</p>
</dd>
<dd>
<p>You also need to compile verilated_vcd_c.cpp and add it to your link,
preferably by adding the dependencies in $(VK_GLOBAL_OBJS) to your
Makefile's link rule.  This is done for you if using the Verilator --exe
flag.</p>
</dd>
<dd>
<p>Note you can also call -&gt;trace on multiple Verilated objects with the same
trace file if you want all data to land in the same output file.</p>
</dd>
<dd>
<p>Note also older versions of Verilator used the SystemPerl package and
SpTraceVcdC class.  This still works, but is depreciated as it requires
strong coupling between the Verilator and SystemPerl versions.</p>
</dd>
<dd>
<pre>
    #include &quot;verilated_vcd_c.h&quot;
    ...
    int main(int argc, char **argv, char **env) {
        ...
        Verilated::traceEverOn(true);
        VerilatedVcdC* tfp = new VerilatedVcdC;
        topp-&gt;trace (tfp, 99);
        tfp-&gt;open (&quot;obj_dir/t_trace_ena_cc/simx.vcd&quot;);
        ...
        while (sc_time_stamp() &lt; sim_time &amp;&amp; !Verilated::gotFinish()) {
            main_time += #;
            tfp-&gt;dump (main_time);
        }
        tfp-&gt;close();
    }</pre>
</dd>
</li>
<dt><strong>How do I generate waveforms (traces) in SystemC?</strong>

<dd>
<p>Add the --trace switch to Verilator, and in your top level C sc_main code,
include verilated_vcd_sc.h.  Then call Verilated::traceEverOn(true).  Then
create a VerilatedVcdSc object as you would create a normal SystemC trace
file.  For an example, see the call to VerilatedVcdSc in the
test_sp/sc_main.cpp file of the distribution, and below.</p>
</dd>
<dd>
<p>Alternatively you may use the C++ trace mechanism described in the previous
question, however the timescale and timeprecision will not inherited from
your SystemC settings.</p>
</dd>
<dd>
<p>You also need to compile verilated_vcd_sc.cpp and verilated_vcd_c.cpp and
add them to your link, preferably by adding the dependencies in
$(VK_GLOBAL_OBJS) to your Makefile's link rule.  This is done for you if
using the Verilator --exe flag.</p>
</dd>
<dd>
<p>Note you can also call -&gt;trace on multiple Verilated objects with the same
trace file if you want all data to land in the same output file.</p>
</dd>
<dd>
<pre>
    #include &quot;verilated_vcd_sc.h&quot;
    ...
    int main(int argc, char **argv, char **env) {
        ...
        Verilated::traceEverOn(true);
        VerilatedVcdSc* tfp = new VerilatedVcdSc;
        topp-&gt;trace (tfp, 99);
        tfp-&gt;open (&quot;obj_dir/t_trace_ena_cc/simx.vcd&quot;);
        ...
        sc_start(1);
        ...
        tfp-&gt;close();
    }</pre>
</dd>
</li>
<dt><strong>How do I view waveforms (traces)?</strong>

<dd>
<p>Verilator makes standard VCD (Value Change Dump) files.  They are viewable
with the public domain Dinotrace or GtkWave programs, or any of the many
commercial offerings.</p>
</dd>
</li>
<dt><strong><a name="waveform" class="item">How do I reduce the size of large waveform (trace) files?</a></strong>

<dd>
<p>First, instead of calling VerilatedVcdC-&gt;open at the beginning of time,
delay calling it until the time stamp where you want to tracing to begin.
Likewise you can also call VerilatedVcdC-&gt;open before the end of time
(perhaps a short period after you detect a verification error.)</p>
</dd>
<dd>
<p>Next, add /*verilator tracing_off*/ to any very low level modules you never
want to trace (such as perhaps library cells).  Finally, use the
--trace-depth option to limit the depth of tracing, for example
--trace-depth 1 to see only the top level signals.</p>
</dd>
<dd>
<p>Also be sure you write your trace files to a local disk, instead of to a
network disk.  Network disks are generally far slower.</p>
</dd>
</li>
<dt><strong><a name="how_do_i_do_coverage_analysis" class="item">How do I do coverage analysis?</a></strong>

<dd>
<p>Verilator supports both block (line) coverage and user inserted functional
coverage.  Both require the SystemPerl package to be installed but do not
require use of the SystemPerl output mode.</p>
</dd>
<dd>
<p>First, run verilator with the --coverage option.  If you're using your own
makefile, compile the model with the GCC flag -DSP_COVERAGE_ENABLE (if
using Verilator's, it will do this for you.)</p>
</dd>
<dd>
<p>Run your tests in different directories.  Each test will create a
logs/coverage.pl file.</p>
</dd>
<dd>
<p>After running all of your tests, the vcoverage utility (from the SystemPerl
package) is executed.  Vcoverage reads the logs/coverage.pl file(s), and
creates an annotated source code listing showing code coverage details.</p>
</dd>
<dd>
<p>For an example, after running 'make test' in the Verilator distribution,
see the test_sp/logs/coverage_source directory.  Grep for lines starting
with '%' to see what lines Verilator believes need more coverage.</p>
</dd>
</li>
<dt><strong><a name="where_is_the_translate_off_command_how_do_i_ignore_a_construct" class="item">Where is the translate_off command?  (How do I ignore a construct?)</a></strong>

<dd>
<p>Translate on/off pragmas are generally a bad idea, as it's easy to have
mismatched pairs, and you can't see what another tool sees by just
preprocessing the code.  Instead, use the preprocessor; Verilator defines
the &quot;VERILATOR&quot; define for you, so just wrap the code in an ifndef region:</p>
</dd>
<dd>
<pre>
   `ifndef VERILATOR
      Something_Verilator_Dislikes;
   `endif</pre>
</dd>
</li>
<dt><strong><a name="why_do_i_get_unexpected_do_or_unexpected_bit_errors" class="item">Why do I get &quot;unexpected `do'&quot; or &quot;unexpected `bit'&quot; errors?</a></strong>

<dd>
<p>Do, bit, ref, return, and other words are now SystemVerilog keywords.  You
should change your code to not use them to insure it works with newer
tools.  Alternatively, surround them by the Verilog 2005/SystemVerilog
begin_keywords pragma to indicate Verilog 2001 code.</p>
</dd>
<dd>
<pre>
   `begin_keywords &quot;1364-2001&quot;
      integer bit; initial bit = 1;
   `end_keywords</pre>
</dd>
<dd>
<p>If you want the whole file to be parsed as Verilog 2001, just create a
file with</p>
</dd>
<dd>
<pre>
   `begin_keywords &quot;1364-2001&quot;</pre>
</dd>
<dd>
<p>and add it before other Verilog files on the command line.  (Note this will
also change the default for --prefix, so if you're not using --prefix, you
will now need to.)</p>
</dd>
</li>
<dt><strong><a name="how_do_i_prevent_my_assertions_from_firing_during_reset" class="item">How do I prevent my assertions from firing during reset?</a></strong>

<dd>
<p>Call Verilated::assertOn(false) before you first call the model, then turn
it back on after reset.  It defaults to true.  When false, all assertions
controlled by --assert are disabled.</p>
</dd>
</li>
<dt><strong><a name="sc_time_stamp" class="item">Why do I get &quot;undefined reference to `sc_time_stamp()'&quot;?</a></strong>

<dd>
<p>In C++ (non SystemC) code you need to define this function so that the
simulator knows the current time.  See the &quot;CONNECTING TO C++&quot; examples.</p>
</dd>
</li>
<dt><strong><a name="why_do_i_get_undefined_reference_to_vl_rand_reset_i_or_verilated" class="item">Why do I get &quot;undefined reference to `VL_RAND_RESET_I' or `Verilated::...'&quot;?</a></strong>

<dd>
<p>You need to link your compiled Verilated code against the verilated.cpp
file found in the include directory of the Verilator kit.  This is one
target in the $(VK_GLOBAL_OBJS) make variable, which should be part of your
Makefile's link rule.</p>
</dd>
</li>
<dt><strong><a name="is_the_pli_supported" class="item">Is the PLI supported?</a></strong>

<dd>
<p>Only somewhat.  More specifically, the common PLI-ish calls $display,
$finish, $stop, $time, $write are converted to C++ equivalents.  You can
also use the &quot;import DPI&quot; SystemVerilog feature to call C code (see the
chapter above).  There is also limited VPI access to public signals.</p>
</dd>
<dd>
<p>If you want something more complex, since Verilator emits standard C++
code, you can simply write your own C++ routines that can access and modify
signal values without needing any PLI interface code, and call it with
$c(&quot;{any_c++_statement}&quot;).</p>
</dd>
</li>
<dt><strong><a name="how_do_i_make_a_verilog_module_that_contain_a_c_object" class="item">How do I make a Verilog module that contain a C++ object?</a></strong>

<dd>
<p>You need to add the object to the structure that Verilator creates, then
use $c to call a method inside your object.  The
test_regress/t/t_extend_class files show an example of how to do this.</p>
</dd>
</li>
<dt><strong><a name="how_do_i_get_faster_build_times" class="item">How do I get faster build times?</a></strong>

<dd>
<p>Between GCC 3.0 to 3.3, each compiled progressively slower, thus if you can
use GCC 2.95, or GCC 3.4 you'll have faster builds.  Two ways to cheat are
to compile on parallel machines and avoid compilations altogether.  See the
--output-split option, and the web for the ccache, distcc and icecream
packages. ccache will skip GCC runs between identical source builds, even
across different users.  You can use the OBJCACHE environment variable to
use these CC wrappers.</p>
</dd>
</li>
<dt><strong><a name="why_do_so_many_files_need_to_recompile_when_i_add_a_signal" class="item">Why do so many files need to recompile when I add a signal?</a></strong>

<dd>
<p>Adding a new signal requires the symbol table to be recompiled.  Verilator
uses one large symbol table, as that results in 2-3 less assembly
instructions for each signal access.  This makes the execution time 10-15%
faster, but can result in more compilations when something changes.</p>
</dd>
</li>
<dt><strong><a name="how_do_i_access_functions_tasks_in_c" class="item">How do I access functions/tasks in C?</a></strong>

<dd>
<p>Use the SystemVerilog Direct Programming Interface.  You write a Verilog
function or task with input/outputs that match what you want to call in
with C.  Then mark that function as an external function.  See the DPI
chapter in the manual.</p>
</dd>
</li>
<dt><strong><a name="how_do_i_access_signals_in_c" class="item">How do I access signals in C?</a></strong>

<dd>
<p>The best thing is to make a SystemVerilog &quot;export DPI task&quot; or function
that accesses that signal, as described in the DPI chapter in the manual
and DPI tutorials on the web.  This will allow Verilator to better optimize
the model and should be portable across simulators.</p>
</dd>
<dd>
<p>If you really want raw access to the signals, declare the signals you will
be accessing with a /*verilator public*/ comment before the closing
semicolon.  Then scope into the C++ class to read the value of the signal,
as you would any other member variable.</p>
</dd>
<dd>
<p>Signals are the smallest of 8-bit chars, 16-bit shorts, 32-bit longs, or
64-bit long longs that fits the width of the signal.  Generally, you can
use just uint32_t's for 1 to 32 bits, or vluint64_t for 1 to 64 bits, and
the compiler will properly up-convert smaller entities.</p>
</dd>
<dd>
<p>Signals wider than 64 bits are stored as an array of 32-bit uint32_t's.
Thus to read bits 31:0, access signal[0], and for bits 63:32, access
signal[1].  Unused bits (for example bit numbers 65-96 of a 65-bit vector)
will always be zero.  if you change the value you must make sure to pack
zeros in the unused bits or core-dumps may result.  (Because Verilator
strips array bound checks where it believes them to be unnecessary.)</p>
</dd>
<dd>
<p>In the SYSTEMC example above, if you had in our.v:</p>
</dd>
<dd>
<pre>
    input clk /*verilator public*/;
    // Note the placement of the semicolon above</pre>
</dd>
<dd>
<p>From the sc_main.cpp file, you'd then:</p>
</dd>
<dd>
<pre>
    #include &quot;Vour.h&quot;
    #include &quot;Vour_our.h&quot;
    cout &lt;&lt; &quot;clock is &quot; &lt;&lt; top-&gt;v-&gt;clk &lt;&lt; endl;</pre>
</dd>
<dd>
<p>In this example, clk is a bool you can read or set as any other variable.
The value of normal signals may be set, though clocks shouldn't be changed
by your code or you'll get strange results.</p>
</dd>
</li>
<dt><strong><a name="should_a_module_be_in_verilog_or_systemc" class="item">Should a module be in Verilog or SystemC?</a></strong>

<dd>
<p>Sometimes there is a block that just interconnects cells, and have a choice
as to if you write it in Verilog or SystemC.  Everything else being equal,
best performance is when Verilator sees all of the design.  So, look at the
hierarchy of your design, labeling cells as to if they are SystemC or
Verilog.  Then:</p>
</dd>
<dd>
<p>A module with only SystemC cells below must be SystemC.</p>
</dd>
<dd>
<p>A module with a mix of Verilog and SystemC cells below must be SystemC. (As
Verilator cannot connect to lower-level SystemC cells.)</p>
</dd>
<dd>
<p>A module with only Verilog cells below can be either, but for best
performance should be Verilog.  (The exception is if you have a design that
is instantiated many times; in this case Verilating one of the lower
modules and instantiating that Verilated cells multiple times into a
SystemC module *may* be faster.)</p>
</dd>
</li>
</dl>
<p>
</p>
<hr />
<h1><a name="bugs">BUGS</a></h1>
<p>First, check the the coding limitations section.</p>
<p>Next, try the --debug switch.  This will enable additional internal
assertions, and may help identify the problem.</p>
<p>Finally, reduce your code to the smallest possible routine that exhibits
the bug.  Even better, create a test in the test_regress/t directory, as
follows:</p>
<pre>
    cd test_regress
    cp -p t/t_EXAMPLE.pl t/t_BUG.pl
    cp -p t/t_EXAMPLE.v t/t_BUG.v</pre>
<p>Edit t/t_BUG.pl to suit your example; you can do anything you want in the
Verilog code there; just make sure it retains the single clk input and no
outputs.  Now, the following should fail:</p>
<pre>
    cd test_regress
    t/t_BUG.pl</pre>
<p>Finally, report the bug using the bug tracker at
<a href="http://www.veripool.org/verilator">http://www.veripool.org/verilator</a>.  The bug will become publicly
visible; if this is unacceptable, mail the bug report to
<code>wsnyder@wsnyder.org</code>.</p>
<p>
</p>
<hr />
<h1><a name="history">HISTORY</a></h1>
<p>Verilator was conceived in 1994 by Paul Wasson at the Core Logic Group
at Digital Equipment Corporation.  The Verilog code that was converted
to C was then merged with a C based CPU model of the Alpha processor
and simulated in a C based environment called CCLI.</p>
<p>In 1995 Verilator started being used also for Multimedia and Network
Processor development inside Digital.  Duane Galbi took over active
development of Verilator, and added several performance enhancements.
CCLI was still being used as the shell.</p>
<p>In 1998, through the efforts of existing DECies, mainly Duane Galbi,
Digital graciously agreed to release the source code.  (Subject to the
code not being resold, which is compatible with the GNU Public
License.)</p>
<p>In 2001, Wilson Snyder took the kit, and added a SystemC mode, and
called it Verilator2.  This was the first packaged public release.</p>
<p>In 2002, Wilson Snyder created Verilator3 by rewriting Verilator from
scratch in C++.  This added many optimizations, yielding about a 2-5x
performance gain.</p>
<p>In 2009, major SystemVerilog and DPI language support was added.</p>
<p>Currently, various language features and performance enhancements are added
as the need arises.  Verilator is now about 3x faster than in 2002, and is
faster than many popular commercial simulators.</p>
<p>
</p>
<hr />
<h1><a name="contributors">CONTRIBUTORS</a></h1>
<p>Many people have provided ideas and other assistance with Verilator.</p>
<p>The major corporate sponsors of Verilator, by providing significant
contributions of time or funds include include Compaq Corporation, Digital
Equipment Corporation, Intel Corporation, Mindspeed Technologies Inc.,
MicroTune Inc., picoChip Designs Ltd., Sun Microsystems, Nauticus Networks,
and SiCortex Inc.</p>
<p>The people who have contributed major functionality are Byron Bradley, Lane
Brooks, Duane Galbi, Paul Wasson, and Wilson Snyder.  Major testers include
Jeff Dutton, Ralf Karge, David Hewson, Wim Michiels, and Gene Weber.</p>
<p>Some of the people who have provided ideas and feedback for Verilator
include: David Addison, Hans Van Antwerpen, Vasu Arasanipalai, Jens Arm, J
Baxter, Jeremy Bennett, David Black, Gregg Bouchard, Christopher Boumenot,
Nick Bowler, Byron Bradley, Bryan Brady, Lane Brooks, John Brownlee,
Lawrence Butcher, Chris Candler, Lauren Carlson, Donal Casey, Terry Chen,
Robert A. Clark, Allan Cochrane, Gunter Dannoritzer, Ashutosh Das, Bernard
Deadman, John Deroo, John Dickol, Danny Ding, Ivan Djordjevic, Alex Duller,
Jeff Dutton, Chandan Egbert, Joe Eiler, Ahmed El-Mahmoudy, Robert Farrell,
Eugen Fekete, Andrea Foletto, Bob Fredieu, Shankar Giri, Sam Gladstone,
Amir Gonnen, Chitlesh Goorah, Neil Hamilton, Thomas Hawkins, David Hewson,
Jae Hossell, Ben Jackson, Iztok Jeras, Mike Kagen, Guy-Armand Kamendje,
Vasu Kandadi, Patricio Kaplan, Ralf Karge, Dan Katz, Sol Katzman, Jonathan
Kimmitt, Gernot Koch, Soon Koh, Steve Kolecki, Steve Lang, Stephane
Laurent, Christian Leber, Charlie Lind, Paul Liu, Dan Lussier, Fred Ma,
Duraid Madina, Mark Marshall, Jason McMullan, Wim Michiels, Dennis
Muhlestein, John Murphy, Richard Myers, Dimitris Nalbantis, Paul Nitza,
Pete Nixon, Lisa Noack, Mark Nodine, Andreas Olofsson, Brad Parker, Dominic
Plunkett, Niranjan Prabhu, Usha Priyadharshini, Oleg Rodionov, John
Sanguinetti, Salman Sheikh, Mike Shinkarovsky, Rafael Shirakawa, Jeffrey
Short, Rodney Sinclair, Brian Small, Alex Solomatnikov, Art Stamness, John
Stroebel, Emerson Suguimoto, Gene Sullivan, Renga Sundararajan, Stefan
Thiede, Gary Thomas, Steve Tong, Holger Waechtler, Stefan Wallentowitz,
Shawn Wang, Greg Waters, Eugene Weber, David Welch, Leon Wildman, Gerald
Williams, Trevor Williams, Jeff Winston, Joshua Wise, Johan Wouters, and
Ding Xiaoliang.</p>
<p>Thanks all.</p>
<p>
</p>
<hr />
<h1><a name="distribution">DISTRIBUTION</a></h1>
<p>The latest version is available from <a href="http://www.veripool.org/">http://www.veripool.org/</a>.</p>
<p>Copyright 2003-2012 by Wilson Snyder.  Verilator is free software; you can
redistribute it and/or modify the Verilator internals under the terms of
either the GNU Lesser General Public License Version 3 or the Perl Artistic
License Version 2.0.</p>
<p>
</p>
<hr />
<h1><a name="authors">AUTHORS</a></h1>
<p>When possible, please instead report bugs to <a href="http://www.veripool.org/">http://www.veripool.org/</a>.</p>
<p>Wilson Snyder &lt;<a href="mailto:wsnyder@wsnyder.org">wsnyder@wsnyder.org</a>&gt;</p>
<p>Major concepts by Paul Wasson and Duane Galbi.</p>
<p>
</p>
<hr />
<h1><a name="see_also">SEE ALSO</a></h1>
<p><em>verilator_profcfunc</em>, <em>systemperl</em>, <em>vcoverage</em>, <em>make</em></p>
<p>And internals.txt in the distribution.</p>

</body>

</html>
